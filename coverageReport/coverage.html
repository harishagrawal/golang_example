
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>gomock: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/golang/mock/gomock/call.go (90.6%)</option>
				
				<option value="file1">github.com/golang/mock/gomock/callset.go (100.0%)</option>
				
				<option value="file2">github.com/golang/mock/gomock/controller.go (80.5%)</option>
				
				<option value="file3">github.com/golang/mock/gomock/internal/mock_gomock/mock_matcher.go (0.0%)</option>
				
				<option value="file4">github.com/golang/mock/gomock/matchers.go (87.1%)</option>
				
				<option value="file5">github.com/golang/mock/mockgen/generic_go118.go (4.4%)</option>
				
				<option value="file6">github.com/golang/mock/mockgen/internal/tests/aux_imports_embedded_interface/bugreport.go (100.0%)</option>
				
				<option value="file7">github.com/golang/mock/mockgen/internal/tests/aux_imports_embedded_interface/bugreport_mock.go (62.5%)</option>
				
				<option value="file8">github.com/golang/mock/mockgen/internal/tests/const_array_length/mock.go (0.0%)</option>
				
				<option value="file9">github.com/golang/mock/mockgen/internal/tests/copyright_file/mock.go (0.0%)</option>
				
				<option value="file10">github.com/golang/mock/mockgen/internal/tests/custom_package_name/client/v1/client.go (100.0%)</option>
				
				<option value="file11">github.com/golang/mock/mockgen/internal/tests/custom_package_name/greeter/greeter.go (75.0%)</option>
				
				<option value="file12">github.com/golang/mock/mockgen/internal/tests/custom_package_name/validator/validate.go (100.0%)</option>
				
				<option value="file13">github.com/golang/mock/mockgen/internal/tests/dot_imports/mock.go (0.0%)</option>
				
				<option value="file14">github.com/golang/mock/mockgen/internal/tests/empty_interface/mock.go (0.0%)</option>
				
				<option value="file15">github.com/golang/mock/mockgen/internal/tests/extra_import/mock.go (0.0%)</option>
				
				<option value="file16">github.com/golang/mock/mockgen/internal/tests/generated_identifier_conflict/bugreport_mock.go (100.0%)</option>
				
				<option value="file17">github.com/golang/mock/mockgen/internal/tests/import_embedded_interface/bugreport.go (100.0%)</option>
				
				<option value="file18">github.com/golang/mock/mockgen/internal/tests/import_embedded_interface/bugreport_mock.go (57.1%)</option>
				
				<option value="file19">github.com/golang/mock/mockgen/internal/tests/import_embedded_interface/faux/conflict.go (0.0%)</option>
				
				<option value="file20">github.com/golang/mock/mockgen/internal/tests/import_embedded_interface/faux/faux.go (0.0%)</option>
				
				<option value="file21">github.com/golang/mock/mockgen/internal/tests/import_embedded_interface/net.go (100.0%)</option>
				
				<option value="file22">github.com/golang/mock/mockgen/internal/tests/import_embedded_interface/net_mock.go (38.1%)</option>
				
				<option value="file23">github.com/golang/mock/mockgen/internal/tests/import_embedded_interface/other/log/log.go (0.0%)</option>
				
				<option value="file24">github.com/golang/mock/mockgen/internal/tests/import_source/definition/source_mock.go (0.0%)</option>
				
				<option value="file25">github.com/golang/mock/mockgen/internal/tests/import_source/source_mock.go (0.0%)</option>
				
				<option value="file26">github.com/golang/mock/mockgen/internal/tests/internal_pkg/subdir/internal/pkg/reflect_output/mock.go (0.0%)</option>
				
				<option value="file27">github.com/golang/mock/mockgen/internal/tests/internal_pkg/subdir/internal/pkg/source_output/mock.go (0.0%)</option>
				
				<option value="file28">github.com/golang/mock/mockgen/internal/tests/missing_import/output/source_mock.go (0.0%)</option>
				
				<option value="file29">github.com/golang/mock/mockgen/internal/tests/overlapping_methods/mock.go (41.7%)</option>
				
				<option value="file30">github.com/golang/mock/mockgen/internal/tests/panicing_test/panic.go (0.0%)</option>
				
				<option value="file31">github.com/golang/mock/mockgen/internal/tests/parenthesized_parameter_type/mock.go (0.0%)</option>
				
				<option value="file32">github.com/golang/mock/mockgen/internal/tests/self_package/mock.go (0.0%)</option>
				
				<option value="file33">github.com/golang/mock/mockgen/internal/tests/unexported_method/bugreport.go (100.0%)</option>
				
				<option value="file34">github.com/golang/mock/mockgen/internal/tests/unexported_method/bugreport_mock.go (100.0%)</option>
				
				<option value="file35">github.com/golang/mock/mockgen/internal/tests/vendor_dep/mock.go (0.0%)</option>
				
				<option value="file36">github.com/golang/mock/mockgen/internal/tests/vendor_dep/source_mock_package/mock.go (0.0%)</option>
				
				<option value="file37">github.com/golang/mock/mockgen/internal/tests/vendor_pkg/mock.go (0.0%)</option>
				
				<option value="file38">github.com/golang/mock/mockgen/mockgen.go (41.9%)</option>
				
				<option value="file39">github.com/golang/mock/mockgen/model/model.go (6.5%)</option>
				
				<option value="file40">github.com/golang/mock/mockgen/parse.go (40.3%)</option>
				
				<option value="file41">github.com/golang/mock/mockgen/reflect.go (0.0%)</option>
				
				<option value="file42">github.com/golang/mock/mockgen/version.go (0.0%)</option>
				
				<option value="file43">github.com/golang/mock/sample/concurrent/mock/concurrent_mock.go (100.0%)</option>
				
				<option value="file44">github.com/golang/mock/sample/user.go (91.7%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">// Copyright 2010 Google Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package gomock

import (
        "fmt"
        "reflect"
        "strconv"
        "strings"
)

// Call represents an expected call to a mock.
type Call struct {
        t TestHelper // for triggering test failures on invalid call setup

        receiver   interface{}  // the receiver of the method call
        method     string       // the name of the method
        methodType reflect.Type // the type of the method
        args       []Matcher    // the args
        origin     string       // file and line number of call setup

        preReqs []*Call // prerequisite calls

        // Expectations
        minCalls, maxCalls int

        numCalls int // actual number made

        // actions are called when this Call is called. Each action gets the args and
        // can set the return values by returning a non-nil slice. Actions run in the
        // order they are created.
        actions []func([]interface{}) []interface{}
}

// newCall creates a *Call. It requires the method type in order to support
// unexported methods.
func newCall(t TestHelper, receiver interface{}, method string, methodType reflect.Type, args ...interface{}) *Call <span class="cov8" title="1">{
        t.Helper()

        // TODO: check arity, types.
        mArgs := make([]Matcher, len(args))
        for i, arg := range args </span><span class="cov8" title="1">{
                if m, ok := arg.(Matcher); ok </span><span class="cov8" title="1">{
                        mArgs[i] = m
                }</span> else<span class="cov8" title="1"> if arg == nil </span><span class="cov8" title="1">{
                        // Handle nil specially so that passing a nil interface value
                        // will match the typed nils of concrete args.
                        mArgs[i] = Nil()
                }</span> else<span class="cov8" title="1"> {
                        mArgs[i] = Eq(arg)
                }</span>
        }

        // callerInfo's skip should be updated if the number of calls between the user's test
        // and this line changes, i.e. this code is wrapped in another anonymous function.
        // 0 is us, 1 is RecordCallWithMethodType(), 2 is the generated recorder, and 3 is the user's test.
        <span class="cov8" title="1">origin := callerInfo(3)
        actions := []func([]interface{}) []interface{}{func([]interface{}) []interface{} </span><span class="cov8" title="1">{
                // Synthesize the zero value for each of the return args' types.
                rets := make([]interface{}, methodType.NumOut())
                for i := 0; i &lt; methodType.NumOut(); i++ </span><span class="cov8" title="1">{
                        rets[i] = reflect.Zero(methodType.Out(i)).Interface()
                }</span>
                <span class="cov8" title="1">return rets</span>
        }}
        <span class="cov8" title="1">return &amp;Call{t: t, receiver: receiver, method: method, methodType: methodType,
                args: mArgs, origin: origin, minCalls: 1, maxCalls: 1, actions: actions}</span>
}

// AnyTimes allows the expectation to be called 0 or more times
func (c *Call) AnyTimes() *Call <span class="cov8" title="1">{
        c.minCalls, c.maxCalls = 0, 1e8 // close enough to infinity
        return c
}</span>

// MinTimes requires the call to occur at least n times. If AnyTimes or MaxTimes have not been called or if MaxTimes
// was previously called with 1, MinTimes also sets the maximum number of calls to infinity.
func (c *Call) MinTimes(n int) *Call <span class="cov8" title="1">{
        c.minCalls = n
        if c.maxCalls == 1 </span><span class="cov8" title="1">{
                c.maxCalls = 1e8
        }</span>
        <span class="cov8" title="1">return c</span>
}

// MaxTimes limits the number of calls to n times. If AnyTimes or MinTimes have not been called or if MinTimes was
// previously called with 1, MaxTimes also sets the minimum number of calls to 0.
func (c *Call) MaxTimes(n int) *Call <span class="cov8" title="1">{
        c.maxCalls = n
        if c.minCalls == 1 </span><span class="cov8" title="1">{
                c.minCalls = 0
        }</span>
        <span class="cov8" title="1">return c</span>
}

// DoAndReturn declares the action to run when the call is matched.
// The return values from this function are returned by the mocked function.
// It takes an interface{} argument to support n-arity functions.
// The anonymous function must match the function signature mocked method.
func (c *Call) DoAndReturn(f interface{}) *Call <span class="cov8" title="1">{
        // TODO: Check arity and types here, rather than dying badly elsewhere.
        v := reflect.ValueOf(f)

        c.addAction(func(args []interface{}) []interface{} </span><span class="cov8" title="1">{
                c.t.Helper()
                ft := v.Type()
                if c.methodType.NumIn() != ft.NumIn() </span><span class="cov8" title="1">{
                        if ft.IsVariadic() </span><span class="cov8" title="1">{
                                c.t.Fatalf("wrong number of arguments in DoAndReturn func for %T.%v The function signature must match the mocked method, a variadic function cannot be used.",
                                        c.receiver, c.method)
                        }</span> else<span class="cov8" title="1"> {
                                c.t.Fatalf("wrong number of arguments in DoAndReturn func for %T.%v: got %d, want %d [%s]",
                                        c.receiver, c.method, ft.NumIn(), c.methodType.NumIn(), c.origin)
                        }</span>
                        <span class="cov8" title="1">return nil</span>
                }
                <span class="cov8" title="1">vArgs := make([]reflect.Value, len(args))
                for i := 0; i &lt; len(args); i++ </span><span class="cov8" title="1">{
                        if args[i] != nil </span><span class="cov8" title="1">{
                                vArgs[i] = reflect.ValueOf(args[i])
                        }</span> else<span class="cov0" title="0"> {
                                // Use the zero value for the arg.
                                vArgs[i] = reflect.Zero(ft.In(i))
                        }</span>
                }
                <span class="cov8" title="1">vRets := v.Call(vArgs)
                rets := make([]interface{}, len(vRets))
                for i, ret := range vRets </span><span class="cov8" title="1">{
                        rets[i] = ret.Interface()
                }</span>
                <span class="cov8" title="1">return rets</span>
        })
        <span class="cov8" title="1">return c</span>
}

// Do declares the action to run when the call is matched. The function's
// return values are ignored to retain backward compatibility. To use the
// return values call DoAndReturn.
// It takes an interface{} argument to support n-arity functions.
// The anonymous function must match the function signature mocked method.
func (c *Call) Do(f interface{}) *Call <span class="cov8" title="1">{
        // TODO: Check arity and types here, rather than dying badly elsewhere.
        v := reflect.ValueOf(f)

        c.addAction(func(args []interface{}) []interface{} </span><span class="cov8" title="1">{
                c.t.Helper()
                ft := v.Type()
                if c.methodType.NumIn() != ft.NumIn() </span><span class="cov8" title="1">{
                        if ft.IsVariadic() </span><span class="cov8" title="1">{
                                c.t.Fatalf("wrong number of arguments in Do func for %T.%v The function signature must match the mocked method, a variadic function cannot be used.",
                                        c.receiver, c.method)
                        }</span> else<span class="cov8" title="1"> {
                                c.t.Fatalf("wrong number of arguments in Do func for %T.%v: got %d, want %d [%s]",
                                        c.receiver, c.method, ft.NumIn(), c.methodType.NumIn(), c.origin)
                        }</span>
                        <span class="cov8" title="1">return nil</span>
                }
                <span class="cov8" title="1">vArgs := make([]reflect.Value, len(args))
                for i := 0; i &lt; len(args); i++ </span><span class="cov8" title="1">{
                        if args[i] != nil </span><span class="cov8" title="1">{
                                vArgs[i] = reflect.ValueOf(args[i])
                        }</span> else<span class="cov0" title="0"> {
                                // Use the zero value for the arg.
                                vArgs[i] = reflect.Zero(ft.In(i))
                        }</span>
                }
                <span class="cov8" title="1">v.Call(vArgs)
                return nil</span>
        })
        <span class="cov8" title="1">return c</span>
}

// Return declares the values to be returned by the mocked function call.
func (c *Call) Return(rets ...interface{}) *Call <span class="cov8" title="1">{
        c.t.Helper()

        mt := c.methodType
        if len(rets) != mt.NumOut() </span><span class="cov0" title="0">{
                c.t.Fatalf("wrong number of arguments to Return for %T.%v: got %d, want %d [%s]",
                        c.receiver, c.method, len(rets), mt.NumOut(), c.origin)
        }</span>
        <span class="cov8" title="1">for i, ret := range rets </span><span class="cov8" title="1">{
                if got, want := reflect.TypeOf(ret), mt.Out(i); got == want </span>{<span class="cov8" title="1">
                        // Identical types; nothing to do.
                }</span> else<span class="cov0" title="0"> if got == nil </span><span class="cov0" title="0">{
                        // Nil needs special handling.
                        switch want.Kind() </span>{
                        case reflect.Chan, reflect.Func, reflect.Interface, reflect.Map, reflect.Ptr, reflect.Slice:<span class="cov0" title="0"></span>
                                // ok
                        default:<span class="cov0" title="0">
                                c.t.Fatalf("argument %d to Return for %T.%v is nil, but %v is not nillable [%s]",
                                        i, c.receiver, c.method, want, c.origin)</span>
                        }
                } else<span class="cov0" title="0"> if got.AssignableTo(want) </span><span class="cov0" title="0">{
                        // Assignable type relation. Make the assignment now so that the generated code
                        // can return the values with a type assertion.
                        v := reflect.New(want).Elem()
                        v.Set(reflect.ValueOf(ret))
                        rets[i] = v.Interface()
                }</span> else<span class="cov0" title="0"> {
                        c.t.Fatalf("wrong type of argument %d to Return for %T.%v: %v is not assignable to %v [%s]",
                                i, c.receiver, c.method, got, want, c.origin)
                }</span>
        }

        <span class="cov8" title="1">c.addAction(func([]interface{}) []interface{} </span><span class="cov8" title="1">{
                return rets
        }</span>)

        <span class="cov8" title="1">return c</span>
}

// Times declares the exact number of times a function call is expected to be executed.
func (c *Call) Times(n int) *Call <span class="cov8" title="1">{
        c.minCalls, c.maxCalls = n, n
        return c
}</span>

// SetArg declares an action that will set the nth argument's value,
// indirected through a pointer. Or, in the case of a slice and map, SetArg
// will copy value's elements/key-value pairs into the nth argument.
func (c *Call) SetArg(n int, value interface{}) *Call <span class="cov8" title="1">{
        c.t.Helper()

        mt := c.methodType
        // TODO: This will break on variadic methods.
        // We will need to check those at invocation time.
        if n &lt; 0 || n &gt;= mt.NumIn() </span><span class="cov0" title="0">{
                c.t.Fatalf("SetArg(%d, ...) called for a method with %d args [%s]",
                        n, mt.NumIn(), c.origin)
        }</span>
        // Permit setting argument through an interface.
        // In the interface case, we don't (nay, can't) check the type here.
        <span class="cov8" title="1">at := mt.In(n)
        switch at.Kind() </span>{
        case reflect.Ptr:<span class="cov8" title="1">
                dt := at.Elem()
                if vt := reflect.TypeOf(value); !vt.AssignableTo(dt) </span><span class="cov0" title="0">{
                        c.t.Fatalf("SetArg(%d, ...) argument is a %v, not assignable to %v [%s]",
                                n, vt, dt, c.origin)
                }</span>
        case reflect.Interface:<span class="cov8" title="1"></span>
                // nothing to do
        case reflect.Slice:<span class="cov8" title="1"></span>
                // nothing to do
        case reflect.Map:<span class="cov8" title="1"></span>
                // nothing to do
        default:<span class="cov8" title="1">
                c.t.Fatalf("SetArg(%d, ...) referring to argument of non-pointer non-interface non-slice non-map type %v [%s]",
                        n, at, c.origin)</span>
        }

        <span class="cov8" title="1">c.addAction(func(args []interface{}) []interface{} </span><span class="cov8" title="1">{
                v := reflect.ValueOf(value)
                switch reflect.TypeOf(args[n]).Kind() </span>{
                case reflect.Slice:<span class="cov8" title="1">
                        setSlice(args[n], v)</span>
                case reflect.Map:<span class="cov8" title="1">
                        setMap(args[n], v)</span>
                default:<span class="cov8" title="1">
                        reflect.ValueOf(args[n]).Elem().Set(v)</span>
                }
                <span class="cov8" title="1">return nil</span>
        })
        <span class="cov8" title="1">return c</span>
}

// isPreReq returns true if other is a direct or indirect prerequisite to c.
func (c *Call) isPreReq(other *Call) bool <span class="cov8" title="1">{
        for _, preReq := range c.preReqs </span><span class="cov8" title="1">{
                if other == preReq || preReq.isPreReq(other) </span><span class="cov8" title="1">{
                        return true
                }</span>
        }
        <span class="cov8" title="1">return false</span>
}

// After declares that the call may only match after preReq has been exhausted.
func (c *Call) After(preReq *Call) *Call <span class="cov8" title="1">{
        c.t.Helper()

        if c == preReq </span><span class="cov8" title="1">{
                c.t.Fatalf("A call isn't allowed to be its own prerequisite")
        }</span>
        <span class="cov8" title="1">if preReq.isPreReq(c) </span><span class="cov8" title="1">{
                c.t.Fatalf("Loop in call order: %v is a prerequisite to %v (possibly indirectly).", c, preReq)
        }</span>

        <span class="cov8" title="1">c.preReqs = append(c.preReqs, preReq)
        return c</span>
}

// Returns true if the minimum number of calls have been made.
func (c *Call) satisfied() bool <span class="cov8" title="1">{
        return c.numCalls &gt;= c.minCalls
}</span>

// Returns true if the maximum number of calls have been made.
func (c *Call) exhausted() bool <span class="cov8" title="1">{
        return c.numCalls &gt;= c.maxCalls
}</span>

func (c *Call) String() string <span class="cov8" title="1">{
        args := make([]string, len(c.args))
        for i, arg := range c.args </span><span class="cov8" title="1">{
                args[i] = arg.String()
        }</span>
        <span class="cov8" title="1">arguments := strings.Join(args, ", ")
        return fmt.Sprintf("%T.%v(%s) %s", c.receiver, c.method, arguments, c.origin)</span>
}

// Tests if the given call matches the expected call.
// If yes, returns nil. If no, returns error with message explaining why it does not match.
func (c *Call) matches(args []interface{}) error <span class="cov8" title="1">{
        if !c.methodType.IsVariadic() </span><span class="cov8" title="1">{
                if len(args) != len(c.args) </span><span class="cov8" title="1">{
                        return fmt.Errorf("expected call at %s has the wrong number of arguments. Got: %d, want: %d",
                                c.origin, len(args), len(c.args))
                }</span>

                <span class="cov8" title="1">for i, m := range c.args </span><span class="cov8" title="1">{
                        if !m.Matches(args[i]) </span><span class="cov8" title="1">{
                                return fmt.Errorf(
                                        "expected call at %s doesn't match the argument at index %d.\nGot: %v\nWant: %v",
                                        c.origin, i, formatGottenArg(m, args[i]), m,
                                )
                        }</span>
                }
        } else<span class="cov8" title="1"> {
                if len(c.args) &lt; c.methodType.NumIn()-1 </span><span class="cov0" title="0">{
                        return fmt.Errorf("expected call at %s has the wrong number of matchers. Got: %d, want: %d",
                                c.origin, len(c.args), c.methodType.NumIn()-1)
                }</span>
                <span class="cov8" title="1">if len(c.args) != c.methodType.NumIn() &amp;&amp; len(args) != len(c.args) </span><span class="cov0" title="0">{
                        return fmt.Errorf("expected call at %s has the wrong number of arguments. Got: %d, want: %d",
                                c.origin, len(args), len(c.args))
                }</span>
                <span class="cov8" title="1">if len(args) &lt; len(c.args)-1 </span><span class="cov0" title="0">{
                        return fmt.Errorf("expected call at %s has the wrong number of arguments. Got: %d, want: greater than or equal to %d",
                                c.origin, len(args), len(c.args)-1)
                }</span>

                <span class="cov8" title="1">for i, m := range c.args </span><span class="cov8" title="1">{
                        if i &lt; c.methodType.NumIn()-1 </span><span class="cov8" title="1">{
                                // Non-variadic args
                                if !m.Matches(args[i]) </span><span class="cov8" title="1">{
                                        return fmt.Errorf("expected call at %s doesn't match the argument at index %s.\nGot: %v\nWant: %v",
                                                c.origin, strconv.Itoa(i), formatGottenArg(m, args[i]), m)
                                }</span>
                                <span class="cov8" title="1">continue</span>
                        }
                        // The last arg has a possibility of a variadic argument, so let it branch

                        // sample: Foo(a int, b int, c ...int)
                        <span class="cov8" title="1">if i &lt; len(c.args) &amp;&amp; i &lt; len(args) </span><span class="cov8" title="1">{
                                if m.Matches(args[i]) </span><span class="cov8" title="1">{
                                        // Got Foo(a, b, c) want Foo(matcherA, matcherB, gomock.Any())
                                        // Got Foo(a, b, c) want Foo(matcherA, matcherB, someSliceMatcher)
                                        // Got Foo(a, b, c) want Foo(matcherA, matcherB, matcherC)
                                        // Got Foo(a, b) want Foo(matcherA, matcherB)
                                        // Got Foo(a, b, c, d) want Foo(matcherA, matcherB, matcherC, matcherD)
                                        continue</span>
                                }
                        }

                        // The number of actual args don't match the number of matchers,
                        // or the last matcher is a slice and the last arg is not.
                        // If this function still matches it is because the last matcher
                        // matches all the remaining arguments or the lack of any.
                        // Convert the remaining arguments, if any, into a slice of the
                        // expected type.
                        <span class="cov8" title="1">vArgsType := c.methodType.In(c.methodType.NumIn() - 1)
                        vArgs := reflect.MakeSlice(vArgsType, 0, len(args)-i)
                        for _, arg := range args[i:] </span><span class="cov8" title="1">{
                                vArgs = reflect.Append(vArgs, reflect.ValueOf(arg))
                        }</span>
                        <span class="cov8" title="1">if m.Matches(vArgs.Interface()) </span><span class="cov8" title="1">{
                                // Got Foo(a, b, c, d, e) want Foo(matcherA, matcherB, gomock.Any())
                                // Got Foo(a, b, c, d, e) want Foo(matcherA, matcherB, someSliceMatcher)
                                // Got Foo(a, b) want Foo(matcherA, matcherB, gomock.Any())
                                // Got Foo(a, b) want Foo(matcherA, matcherB, someEmptySliceMatcher)
                                break</span>
                        }
                        // Wrong number of matchers or not match. Fail.
                        // Got Foo(a, b) want Foo(matcherA, matcherB, matcherC, matcherD)
                        // Got Foo(a, b, c) want Foo(matcherA, matcherB, matcherC, matcherD)
                        // Got Foo(a, b, c, d) want Foo(matcherA, matcherB, matcherC, matcherD, matcherE)
                        // Got Foo(a, b, c, d, e) want Foo(matcherA, matcherB, matcherC, matcherD)
                        // Got Foo(a, b, c) want Foo(matcherA, matcherB)

                        <span class="cov8" title="1">return fmt.Errorf("expected call at %s doesn't match the argument at index %s.\nGot: %v\nWant: %v",
                                c.origin, strconv.Itoa(i), formatGottenArg(m, args[i:]), c.args[i])</span>
                }
        }

        // Check that all prerequisite calls have been satisfied.
        <span class="cov8" title="1">for _, preReqCall := range c.preReqs </span><span class="cov8" title="1">{
                if !preReqCall.satisfied() </span><span class="cov8" title="1">{
                        return fmt.Errorf("expected call at %s doesn't have a prerequisite call satisfied:\n%v\nshould be called before:\n%v",
                                c.origin, preReqCall, c)
                }</span>
        }

        // Check that the call is not exhausted.
        <span class="cov8" title="1">if c.exhausted() </span><span class="cov8" title="1">{
                return fmt.Errorf("expected call at %s has already been called the max number of times", c.origin)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// dropPrereqs tells the expected Call to not re-check prerequisite calls any
// longer, and to return its current set.
func (c *Call) dropPrereqs() (preReqs []*Call) <span class="cov8" title="1">{
        preReqs = c.preReqs
        c.preReqs = nil
        return
}</span>

func (c *Call) call() []func([]interface{}) []interface{} <span class="cov8" title="1">{
        c.numCalls++
        return c.actions
}</span>

// InOrder declares that the given calls should occur in order.
func InOrder(calls ...*Call) <span class="cov8" title="1">{
        for i := 1; i &lt; len(calls); i++ </span><span class="cov8" title="1">{
                calls[i].After(calls[i-1])
        }</span>
}

func setSlice(arg interface{}, v reflect.Value) <span class="cov8" title="1">{
        va := reflect.ValueOf(arg)
        for i := 0; i &lt; v.Len(); i++ </span><span class="cov8" title="1">{
                va.Index(i).Set(v.Index(i))
        }</span>
}

func setMap(arg interface{}, v reflect.Value) <span class="cov8" title="1">{
        va := reflect.ValueOf(arg)
        for _, e := range va.MapKeys() </span><span class="cov8" title="1">{
                va.SetMapIndex(e, reflect.Value{})
        }</span>
        <span class="cov8" title="1">for _, e := range v.MapKeys() </span><span class="cov8" title="1">{
                va.SetMapIndex(e, v.MapIndex(e))
        }</span>
}

func (c *Call) addAction(action func([]interface{}) []interface{}) <span class="cov8" title="1">{
        c.actions = append(c.actions, action)
}</span>

func formatGottenArg(m Matcher, arg interface{}) string <span class="cov8" title="1">{
        got := fmt.Sprintf("%v (%T)", arg, arg)
        if gs, ok := m.(GotFormatter); ok </span><span class="cov8" title="1">{
                got = gs.Got(arg)
        }</span>
        <span class="cov8" title="1">return got</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">// Copyright 2011 Google Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package gomock

import (
        "bytes"
        "errors"
        "fmt"
)

// callSet represents a set of expected calls, indexed by receiver and method
// name.
type callSet struct {
        // Calls that are still expected.
        expected map[callSetKey][]*Call
        // Calls that have been exhausted.
        exhausted map[callSetKey][]*Call
}

// callSetKey is the key in the maps in callSet
type callSetKey struct {
        receiver interface{}
        fname    string
}

func newCallSet() *callSet <span class="cov8" title="1">{
        return &amp;callSet{make(map[callSetKey][]*Call), make(map[callSetKey][]*Call)}
}</span>

// Add adds a new expected call.
func (cs callSet) Add(call *Call) <span class="cov8" title="1">{
        key := callSetKey{call.receiver, call.method}
        m := cs.expected
        if call.exhausted() </span><span class="cov8" title="1">{
                m = cs.exhausted
        }</span>
        <span class="cov8" title="1">m[key] = append(m[key], call)</span>
}

// Remove removes an expected call.
func (cs callSet) Remove(call *Call) <span class="cov8" title="1">{
        key := callSetKey{call.receiver, call.method}
        calls := cs.expected[key]
        for i, c := range calls </span><span class="cov8" title="1">{
                if c == call </span><span class="cov8" title="1">{
                        // maintain order for remaining calls
                        cs.expected[key] = append(calls[:i], calls[i+1:]...)
                        cs.exhausted[key] = append(cs.exhausted[key], call)
                        break</span>
                }
        }
}

// FindMatch searches for a matching call. Returns error with explanation message if no call matched.
func (cs callSet) FindMatch(receiver interface{}, method string, args []interface{}) (*Call, error) <span class="cov8" title="1">{
        key := callSetKey{receiver, method}

        // Search through the expected calls.
        expected := cs.expected[key]
        var callsErrors bytes.Buffer
        for _, call := range expected </span><span class="cov8" title="1">{
                err := call.matches(args)
                if err != nil </span><span class="cov8" title="1">{
                        _, _ = fmt.Fprintf(&amp;callsErrors, "\n%v", err)
                }</span> else<span class="cov8" title="1"> {
                        return call, nil
                }</span>
        }

        // If we haven't found a match then search through the exhausted calls so we
        // get useful error messages.
        <span class="cov8" title="1">exhausted := cs.exhausted[key]
        for _, call := range exhausted </span><span class="cov8" title="1">{
                if err := call.matches(args); err != nil </span><span class="cov8" title="1">{
                        _, _ = fmt.Fprintf(&amp;callsErrors, "\n%v", err)
                        continue</span>
                }
                <span class="cov8" title="1">_, _ = fmt.Fprintf(
                        &amp;callsErrors, "all expected calls for method %q have been exhausted", method,
                )</span>
        }

        <span class="cov8" title="1">if len(expected)+len(exhausted) == 0 </span><span class="cov8" title="1">{
                _, _ = fmt.Fprintf(&amp;callsErrors, "there are no expected calls of the method %q for that receiver", method)
        }</span>

        <span class="cov8" title="1">return nil, errors.New(callsErrors.String())</span>
}

// Failures returns the calls that are not satisfied.
func (cs callSet) Failures() []*Call <span class="cov8" title="1">{
        failures := make([]*Call, 0, len(cs.expected))
        for _, calls := range cs.expected </span><span class="cov8" title="1">{
                for _, call := range calls </span><span class="cov8" title="1">{
                        if !call.satisfied() </span><span class="cov8" title="1">{
                                failures = append(failures, call)
                        }</span>
                }
        }
        <span class="cov8" title="1">return failures</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">// Copyright 2010 Google Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package gomock

import (
        "context"
        "fmt"
        "reflect"
        "runtime"
        "sync"
)

// A TestReporter is something that can be used to report test failures.  It
// is satisfied by the standard library's *testing.T.
type TestReporter interface {
        Errorf(format string, args ...interface{})
        Fatalf(format string, args ...interface{})
}

// TestHelper is a TestReporter that has the Helper method.  It is satisfied
// by the standard library's *testing.T.
type TestHelper interface {
        TestReporter
        Helper()
}

// cleanuper is used to check if TestHelper also has the `Cleanup` method. A
// common pattern is to pass in a `*testing.T` to
// `NewController(t TestReporter)`. In Go 1.14+, `*testing.T` has a cleanup
// method. This can be utilized to call `Finish()` so the caller of this library
// does not have to.
type cleanuper interface {
        Cleanup(func())
}

// A Controller represents the top-level control of a mock ecosystem.  It
// defines the scope and lifetime of mock objects, as well as their
// expectations.  It is safe to call Controller's methods from multiple
// goroutines. Each test should create a new Controller and invoke Finish via
// defer.
//
//   func TestFoo(t *testing.T) {
//     ctrl := gomock.NewController(t)
//     defer ctrl.Finish()
//     // ..
//   }
//
//   func TestBar(t *testing.T) {
//     t.Run("Sub-Test-1", st) {
//       ctrl := gomock.NewController(st)
//       defer ctrl.Finish()
//       // ..
//     })
//     t.Run("Sub-Test-2", st) {
//       ctrl := gomock.NewController(st)
//       defer ctrl.Finish()
//       // ..
//     })
//   })
type Controller struct {
        // T should only be called within a generated mock. It is not intended to
        // be used in user code and may be changed in future versions. T is the
        // TestReporter passed in when creating the Controller via NewController.
        // If the TestReporter does not implement a TestHelper it will be wrapped
        // with a nopTestHelper.
        T             TestHelper
        mu            sync.Mutex
        expectedCalls *callSet
        finished      bool
}

// NewController returns a new Controller. It is the preferred way to create a
// Controller.
//
// New in go1.14+, if you are passing a *testing.T into this function you no
// longer need to call ctrl.Finish() in your test methods.
func NewController(t TestReporter) *Controller <span class="cov8" title="1">{
        h, ok := t.(TestHelper)
        if !ok </span><span class="cov8" title="1">{
                h = &amp;nopTestHelper{t}
        }</span>
        <span class="cov8" title="1">ctrl := &amp;Controller{
                T:             h,
                expectedCalls: newCallSet(),
        }
        if c, ok := isCleanuper(ctrl.T); ok </span><span class="cov8" title="1">{
                c.Cleanup(func() </span><span class="cov8" title="1">{
                        ctrl.T.Helper()
                        ctrl.finish(true, nil)
                }</span>)
        }

        <span class="cov8" title="1">return ctrl</span>
}

type cancelReporter struct {
        t      TestHelper
        cancel func()
}

func (r *cancelReporter) Errorf(format string, args ...interface{}) <span class="cov0" title="0">{
        r.t.Errorf(format, args...)
}</span>
func (r *cancelReporter) Fatalf(format string, args ...interface{}) <span class="cov0" title="0">{
        defer r.cancel()
        r.t.Fatalf(format, args...)
}</span>

func (r *cancelReporter) Helper() <span class="cov0" title="0">{
        r.t.Helper()
}</span>

// WithContext returns a new Controller and a Context, which is cancelled on any
// fatal failure.
func WithContext(ctx context.Context, t TestReporter) (*Controller, context.Context) <span class="cov0" title="0">{
        h, ok := t.(TestHelper)
        if !ok </span><span class="cov0" title="0">{
                h = &amp;nopTestHelper{t: t}
        }</span>

        <span class="cov0" title="0">ctx, cancel := context.WithCancel(ctx)
        return NewController(&amp;cancelReporter{t: h, cancel: cancel}), ctx</span>
}

type nopTestHelper struct {
        t TestReporter
}

func (h *nopTestHelper) Errorf(format string, args ...interface{}) <span class="cov8" title="1">{
        h.t.Errorf(format, args...)
}</span>
func (h *nopTestHelper) Fatalf(format string, args ...interface{}) <span class="cov8" title="1">{
        h.t.Fatalf(format, args...)
}</span>

func (h nopTestHelper) Helper() {<span class="cov8" title="1">}</span>

// RecordCall is called by a mock. It should not be called by user code.
func (ctrl *Controller) RecordCall(receiver interface{}, method string, args ...interface{}) *Call <span class="cov8" title="1">{
        ctrl.T.Helper()

        recv := reflect.ValueOf(receiver)
        for i := 0; i &lt; recv.Type().NumMethod(); i++ </span><span class="cov8" title="1">{
                if recv.Type().Method(i).Name == method </span><span class="cov8" title="1">{
                        return ctrl.RecordCallWithMethodType(receiver, method, recv.Method(i).Type(), args...)
                }</span>
        }
        <span class="cov0" title="0">ctrl.T.Fatalf("gomock: failed finding method %s on %T", method, receiver)
        panic("unreachable")</span>
}

// RecordCallWithMethodType is called by a mock. It should not be called by user code.
func (ctrl *Controller) RecordCallWithMethodType(receiver interface{}, method string, methodType reflect.Type, args ...interface{}) *Call <span class="cov8" title="1">{
        ctrl.T.Helper()

        call := newCall(ctrl.T, receiver, method, methodType, args...)

        ctrl.mu.Lock()
        defer ctrl.mu.Unlock()
        ctrl.expectedCalls.Add(call)

        return call
}</span>

// Call is called by a mock. It should not be called by user code.
func (ctrl *Controller) Call(receiver interface{}, method string, args ...interface{}) []interface{} <span class="cov8" title="1">{
        ctrl.T.Helper()

        // Nest this code so we can use defer to make sure the lock is released.
        actions := func() []func([]interface{}) []interface{} </span><span class="cov8" title="1">{
                ctrl.T.Helper()
                ctrl.mu.Lock()
                defer ctrl.mu.Unlock()

                expected, err := ctrl.expectedCalls.FindMatch(receiver, method, args)
                if err != nil </span><span class="cov8" title="1">{
                        // callerInfo's skip should be updated if the number of calls between the user's test
                        // and this line changes, i.e. this code is wrapped in another anonymous function.
                        // 0 is us, 1 is controller.Call(), 2 is the generated mock, and 3 is the user's test.
                        origin := callerInfo(3)
                        ctrl.T.Fatalf("Unexpected call to %T.%v(%v) at %s because: %s", receiver, method, args, origin, err)
                }</span>

                // Two things happen here:
                // * the matching call no longer needs to check prerequite calls,
                // * and the prerequite calls are no longer expected, so remove them.
                <span class="cov8" title="1">preReqCalls := expected.dropPrereqs()
                for _, preReqCall := range preReqCalls </span><span class="cov8" title="1">{
                        ctrl.expectedCalls.Remove(preReqCall)
                }</span>

                <span class="cov8" title="1">actions := expected.call()
                if expected.exhausted() </span><span class="cov8" title="1">{
                        ctrl.expectedCalls.Remove(expected)
                }</span>
                <span class="cov8" title="1">return actions</span>
        }()

        <span class="cov8" title="1">var rets []interface{}
        for _, action := range actions </span><span class="cov8" title="1">{
                if r := action(args); r != nil </span><span class="cov8" title="1">{
                        rets = r
                }</span>
        }

        <span class="cov8" title="1">return rets</span>
}

// Finish checks to see if all the methods that were expected to be called
// were called. It should be invoked for each Controller. It is not idempotent
// and therefore can only be invoked once.
//
// New in go1.14+, if you are passing a *testing.T into NewController function you no
// longer need to call ctrl.Finish() in your test methods.
func (ctrl *Controller) Finish() <span class="cov8" title="1">{
        // If we're currently panicking, probably because this is a deferred call.
        // This must be recovered in the deferred function.
        err := recover()
        ctrl.finish(false, err)
}</span>

func (ctrl *Controller) finish(cleanup bool, panicErr interface{}) <span class="cov8" title="1">{
        ctrl.T.Helper()

        ctrl.mu.Lock()
        defer ctrl.mu.Unlock()

        if ctrl.finished </span><span class="cov8" title="1">{
                if _, ok := isCleanuper(ctrl.T); !ok </span><span class="cov0" title="0">{
                        ctrl.T.Fatalf("Controller.Finish was called more than once. It has to be called exactly once.")
                }</span>
                <span class="cov8" title="1">return</span>
        }
        <span class="cov8" title="1">ctrl.finished = true

        // Short-circuit, pass through the panic.
        if panicErr != nil </span><span class="cov8" title="1">{
                panic(panicErr)</span>
        }

        // Check that all remaining expected calls are satisfied.
        <span class="cov8" title="1">failures := ctrl.expectedCalls.Failures()
        for _, call := range failures </span><span class="cov8" title="1">{
                ctrl.T.Errorf("missing call(s) to %v", call)
        }</span>
        <span class="cov8" title="1">if len(failures) != 0 </span><span class="cov8" title="1">{
                if !cleanup </span><span class="cov8" title="1">{
                        ctrl.T.Fatalf("aborting test due to missing call(s)")
                        return
                }</span>
                <span class="cov0" title="0">ctrl.T.Errorf("aborting test due to missing call(s)")</span>
        }
}

// callerInfo returns the file:line of the call site. skip is the number
// of stack frames to skip when reporting. 0 is callerInfo's call site.
func callerInfo(skip int) string <span class="cov8" title="1">{
        if _, file, line, ok := runtime.Caller(skip + 1); ok </span><span class="cov8" title="1">{
                return fmt.Sprintf("%s:%d", file, line)
        }</span>
        <span class="cov0" title="0">return "unknown file"</span>
}

// isCleanuper checks it if t's base TestReporter has a Cleanup method.
func isCleanuper(t TestReporter) (cleanuper, bool) <span class="cov8" title="1">{
        tr := unwrapTestReporter(t)
        c, ok := tr.(cleanuper)
        return c, ok
}</span>

// unwrapTestReporter unwraps TestReporter to the base implementation.
func unwrapTestReporter(t TestReporter) TestReporter <span class="cov8" title="1">{
        tr := t
        switch nt := t.(type) </span>{
        case *cancelReporter:<span class="cov0" title="0">
                tr = nt.t
                if h, check := tr.(*nopTestHelper); check </span><span class="cov0" title="0">{
                        tr = h.t
                }</span>
        case *nopTestHelper:<span class="cov8" title="1">
                tr = nt.t</span>
        default:<span class="cov8" title="1"></span>
                // not wrapped
        }
        <span class="cov8" title="1">return tr</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">// Code generated by MockGen. DO NOT EDIT.
// Source: github.com/golang/mock/gomock (interfaces: Matcher)

// Package mock_gomock is a generated GoMock package.
package mock_gomock

import (
        reflect "reflect"

        gomock "github.com/golang/mock/gomock"
)

// MockMatcher is a mock of Matcher interface.
type MockMatcher struct {
        ctrl     *gomock.Controller
        recorder *MockMatcherMockRecorder
}

// MockMatcherMockRecorder is the mock recorder for MockMatcher.
type MockMatcherMockRecorder struct {
        mock *MockMatcher
}

// NewMockMatcher creates a new mock instance.
func NewMockMatcher(ctrl *gomock.Controller) *MockMatcher <span class="cov0" title="0">{
        mock := &amp;MockMatcher{ctrl: ctrl}
        mock.recorder = &amp;MockMatcherMockRecorder{mock}
        return mock
}</span>

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockMatcher) EXPECT() *MockMatcherMockRecorder <span class="cov0" title="0">{
        return m.recorder
}</span>

// Matches mocks base method.
func (m *MockMatcher) Matches(arg0 interface{}) bool <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Matches", arg0)
        ret0, _ := ret[0].(bool)
        return ret0
}</span>

// Matches indicates an expected call of Matches.
func (mr *MockMatcherMockRecorder) Matches(arg0 interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Matches", reflect.TypeOf((*MockMatcher)(nil).Matches), arg0)
}</span>

// String mocks base method.
func (m *MockMatcher) String() string <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "String")
        ret0, _ := ret[0].(string)
        return ret0
}</span>

// String indicates an expected call of String.
func (mr *MockMatcherMockRecorder) String() *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "String", reflect.TypeOf((*MockMatcher)(nil).String))
}</span>
</pre>
		
		<pre class="file" id="file4" style="display: none">// Copyright 2010 Google Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package gomock

import (
        "fmt"
        "reflect"
        "strings"
)

// A Matcher is a representation of a class of values.
// It is used to represent the valid or expected arguments to a mocked method.
type Matcher interface {
        // Matches returns whether x is a match.
        Matches(x interface{}) bool

        // String describes what the matcher matches.
        String() string
}

// WantFormatter modifies the given Matcher's String() method to the given
// Stringer. This allows for control on how the "Want" is formatted when
// printing .
func WantFormatter(s fmt.Stringer, m Matcher) Matcher <span class="cov8" title="1">{
        type matcher interface {
                Matches(x interface{}) bool
        }

        return struct {
                matcher
                fmt.Stringer
        }{
                matcher:  m,
                Stringer: s,
        }
}</span>

// StringerFunc type is an adapter to allow the use of ordinary functions as
// a Stringer. If f is a function with the appropriate signature,
// StringerFunc(f) is a Stringer that calls f.
type StringerFunc func() string

// String implements fmt.Stringer.
func (f StringerFunc) String() string <span class="cov8" title="1">{
        return f()
}</span>

// GotFormatter is used to better print failure messages. If a matcher
// implements GotFormatter, it will use the result from Got when printing
// the failure message.
type GotFormatter interface {
        // Got is invoked with the received value. The result is used when
        // printing the failure message.
        Got(got interface{}) string
}

// GotFormatterFunc type is an adapter to allow the use of ordinary
// functions as a GotFormatter. If f is a function with the appropriate
// signature, GotFormatterFunc(f) is a GotFormatter that calls f.
type GotFormatterFunc func(got interface{}) string

// Got implements GotFormatter.
func (f GotFormatterFunc) Got(got interface{}) string <span class="cov8" title="1">{
        return f(got)
}</span>

// GotFormatterAdapter attaches a GotFormatter to a Matcher.
func GotFormatterAdapter(s GotFormatter, m Matcher) Matcher <span class="cov8" title="1">{
        return struct {
                GotFormatter
                Matcher
        }{
                GotFormatter: s,
                Matcher:      m,
        }
}</span>

type anyMatcher struct{}

func (anyMatcher) Matches(interface{}) bool <span class="cov8" title="1">{
        return true
}</span>

func (anyMatcher) String() string <span class="cov0" title="0">{
        return "is anything"
}</span>

type eqMatcher struct {
        x interface{}
}

func (e eqMatcher) Matches(x interface{}) bool <span class="cov8" title="1">{
        // In case, some value is nil
        if e.x == nil || x == nil </span><span class="cov8" title="1">{
                return reflect.DeepEqual(e.x, x)
        }</span>

        // Check if types assignable and convert them to common type
        <span class="cov8" title="1">x1Val := reflect.ValueOf(e.x)
        x2Val := reflect.ValueOf(x)

        if x1Val.Type().AssignableTo(x2Val.Type()) </span><span class="cov8" title="1">{
                x1ValConverted := x1Val.Convert(x2Val.Type())
                return reflect.DeepEqual(x1ValConverted.Interface(), x2Val.Interface())
        }</span>

        <span class="cov8" title="1">return false</span>
}

func (e eqMatcher) String() string <span class="cov8" title="1">{
        return fmt.Sprintf("is equal to %v (%T)", e.x, e.x)
}</span>

type nilMatcher struct{}

func (nilMatcher) Matches(x interface{}) bool <span class="cov8" title="1">{
        if x == nil </span><span class="cov8" title="1">{
                return true
        }</span>

        <span class="cov8" title="1">v := reflect.ValueOf(x)
        switch v.Kind() </span>{
        case reflect.Chan, reflect.Func, reflect.Interface, reflect.Map,
                reflect.Ptr, reflect.Slice:<span class="cov8" title="1">
                return v.IsNil()</span>
        }

        <span class="cov8" title="1">return false</span>
}

func (nilMatcher) String() string <span class="cov0" title="0">{
        return "is nil"
}</span>

type notMatcher struct {
        m Matcher
}

func (n notMatcher) Matches(x interface{}) bool <span class="cov8" title="1">{
        return !n.m.Matches(x)
}</span>

func (n notMatcher) String() string <span class="cov0" title="0">{
        return "not(" + n.m.String() + ")"
}</span>

type assignableToTypeOfMatcher struct {
        targetType reflect.Type
}

func (m assignableToTypeOfMatcher) Matches(x interface{}) bool <span class="cov8" title="1">{
        return reflect.TypeOf(x).AssignableTo(m.targetType)
}</span>

func (m assignableToTypeOfMatcher) String() string <span class="cov0" title="0">{
        return "is assignable to " + m.targetType.Name()
}</span>

type allMatcher struct {
        matchers []Matcher
}

func (am allMatcher) Matches(x interface{}) bool <span class="cov8" title="1">{
        for _, m := range am.matchers </span><span class="cov8" title="1">{
                if !m.Matches(x) </span><span class="cov8" title="1">{
                        return false
                }</span>
        }
        <span class="cov8" title="1">return true</span>
}

func (am allMatcher) String() string <span class="cov0" title="0">{
        ss := make([]string, 0, len(am.matchers))
        for _, matcher := range am.matchers </span><span class="cov0" title="0">{
                ss = append(ss, matcher.String())
        }</span>
        <span class="cov0" title="0">return strings.Join(ss, "; ")</span>
}

type lenMatcher struct {
        i int
}

func (m lenMatcher) Matches(x interface{}) bool <span class="cov8" title="1">{
        v := reflect.ValueOf(x)
        switch v.Kind() </span>{
        case reflect.Array, reflect.Chan, reflect.Map, reflect.Slice, reflect.String:<span class="cov8" title="1">
                return v.Len() == m.i</span>
        default:<span class="cov8" title="1">
                return false</span>
        }
}

func (m lenMatcher) String() string <span class="cov0" title="0">{
        return fmt.Sprintf("has length %d", m.i)
}</span>

type inAnyOrderMatcher struct {
        x interface{}
}

func (m inAnyOrderMatcher) Matches(x interface{}) bool <span class="cov8" title="1">{
        given, ok := m.prepareValue(x)
        if !ok </span><span class="cov8" title="1">{
                return false
        }</span>
        <span class="cov8" title="1">wanted, ok := m.prepareValue(m.x)
        if !ok </span><span class="cov8" title="1">{
                return false
        }</span>

        <span class="cov8" title="1">if given.Len() != wanted.Len() </span><span class="cov8" title="1">{
                return false
        }</span>

        <span class="cov8" title="1">usedFromGiven := make([]bool, given.Len())
        foundFromWanted := make([]bool, wanted.Len())
        for i := 0; i &lt; wanted.Len(); i++ </span><span class="cov8" title="1">{
                wantedMatcher := Eq(wanted.Index(i).Interface())
                for j := 0; j &lt; given.Len(); j++ </span><span class="cov8" title="1">{
                        if usedFromGiven[j] </span><span class="cov8" title="1">{
                                continue</span>
                        }
                        <span class="cov8" title="1">if wantedMatcher.Matches(given.Index(j).Interface()) </span><span class="cov8" title="1">{
                                foundFromWanted[i] = true
                                usedFromGiven[j] = true
                                break</span>
                        }
                }
        }

        <span class="cov8" title="1">missingFromWanted := 0
        for _, found := range foundFromWanted </span><span class="cov8" title="1">{
                if !found </span><span class="cov8" title="1">{
                        missingFromWanted++
                }</span>
        }
        <span class="cov8" title="1">extraInGiven := 0
        for _, used := range usedFromGiven </span><span class="cov8" title="1">{
                if !used </span><span class="cov8" title="1">{
                        extraInGiven++
                }</span>
        }

        <span class="cov8" title="1">return extraInGiven == 0 &amp;&amp; missingFromWanted == 0</span>
}

func (m inAnyOrderMatcher) prepareValue(x interface{}) (reflect.Value, bool) <span class="cov8" title="1">{
        xValue := reflect.ValueOf(x)
        switch xValue.Kind() </span>{
        case reflect.Slice, reflect.Array:<span class="cov8" title="1">
                return xValue, true</span>
        default:<span class="cov8" title="1">
                return reflect.Value{}, false</span>
        }
}

func (m inAnyOrderMatcher) String() string <span class="cov0" title="0">{
        return fmt.Sprintf("has the same elements as %v", m.x)
}</span>

// Constructors

// All returns a composite Matcher that returns true if and only all of the
// matchers return true.
func All(ms ...Matcher) Matcher <span class="cov8" title="1">{ return allMatcher{ms} }</span>

// Any returns a matcher that always matches.
func Any() Matcher <span class="cov8" title="1">{ return anyMatcher{} }</span>

// Eq returns a matcher that matches on equality.
//
// Example usage:
//   Eq(5).Matches(5) // returns true
//   Eq(5).Matches(4) // returns false
func Eq(x interface{}) Matcher <span class="cov8" title="1">{ return eqMatcher{x} }</span>

// Len returns a matcher that matches on length. This matcher returns false if
// is compared to a type that is not an array, chan, map, slice, or string.
func Len(i int) Matcher <span class="cov8" title="1">{
        return lenMatcher{i}
}</span>

// Nil returns a matcher that matches if the received value is nil.
//
// Example usage:
//   var x *bytes.Buffer
//   Nil().Matches(x) // returns true
//   x = &amp;bytes.Buffer{}
//   Nil().Matches(x) // returns false
func Nil() Matcher <span class="cov8" title="1">{ return nilMatcher{} }</span>

// Not reverses the results of its given child matcher.
//
// Example usage:
//   Not(Eq(5)).Matches(4) // returns true
//   Not(Eq(5)).Matches(5) // returns false
func Not(x interface{}) Matcher <span class="cov8" title="1">{
        if m, ok := x.(Matcher); ok </span><span class="cov8" title="1">{
                return notMatcher{m}
        }</span>
        <span class="cov0" title="0">return notMatcher{Eq(x)}</span>
}

// AssignableToTypeOf is a Matcher that matches if the parameter to the mock
// function is assignable to the type of the parameter to this function.
//
// Example usage:
//   var s fmt.Stringer = &amp;bytes.Buffer{}
//   AssignableToTypeOf(s).Matches(time.Second) // returns true
//   AssignableToTypeOf(s).Matches(99) // returns false
//
//   var ctx = reflect.TypeOf((*context.Context)(nil)).Elem()
//   AssignableToTypeOf(ctx).Matches(context.Background()) // returns true
func AssignableToTypeOf(x interface{}) Matcher <span class="cov8" title="1">{
        if xt, ok := x.(reflect.Type); ok </span><span class="cov8" title="1">{
                return assignableToTypeOfMatcher{xt}
        }</span>
        <span class="cov8" title="1">return assignableToTypeOfMatcher{reflect.TypeOf(x)}</span>
}

// InAnyOrder is a Matcher that returns true for collections of the same elements ignoring the order.
//
// Example usage:
//   InAnyOrder([]int{1, 2, 3}).Matches([]int{1, 3, 2}) // returns true
//   InAnyOrder([]int{1, 2, 3}).Matches([]int{1, 2}) // returns false
func InAnyOrder(x interface{}) Matcher <span class="cov8" title="1">{
        return inAnyOrderMatcher{x}
}</span>
</pre>
		
		<pre class="file" id="file5" style="display: none">// Copyright 2022 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// See the License for the specific language governing permissions and
// limitations under the License.

//go:build go1.18
// +build go1.18

package main

import (
        "go/ast"
        "strings"

        "github.com/golang/mock/mockgen/model"
)

func getTypeSpecTypeParams(ts *ast.TypeSpec) []*ast.Field <span class="cov8" title="1">{
        if ts == nil || ts.TypeParams == nil </span><span class="cov8" title="1">{
                return nil
        }</span>
        <span class="cov0" title="0">return ts.TypeParams.List</span>
}

func (p *fileParser) parseGenericType(pkg string, typ ast.Expr, tps map[string]bool) (model.Type, error) <span class="cov0" title="0">{
        switch v := typ.(type) </span>{
        case *ast.IndexExpr:<span class="cov0" title="0">
                m, err := p.parseType(pkg, v.X, tps)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">nm, ok := m.(*model.NamedType)
                if !ok </span><span class="cov0" title="0">{
                        return m, nil
                }</span>
                <span class="cov0" title="0">t, err := p.parseType(pkg, v.Index, tps)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">nm.TypeParams = &amp;model.TypeParametersType{TypeParameters: []model.Type{t}}
                return m, nil</span>
        case *ast.IndexListExpr:<span class="cov0" title="0">
                m, err := p.parseType(pkg, v.X, tps)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">nm, ok := m.(*model.NamedType)
                if !ok </span><span class="cov0" title="0">{
                        return m, nil
                }</span>
                <span class="cov0" title="0">var ts []model.Type
                for _, expr := range v.Indices </span><span class="cov0" title="0">{
                        t, err := p.parseType(pkg, expr, tps)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                        <span class="cov0" title="0">ts = append(ts, t)</span>
                }
                <span class="cov0" title="0">nm.TypeParams = &amp;model.TypeParametersType{TypeParameters: ts}
                return m, nil</span>
        }
        <span class="cov0" title="0">return nil, nil</span>
}

func getIdentTypeParams(decl interface{}) string <span class="cov0" title="0">{
        if decl == nil </span><span class="cov0" title="0">{
                return ""
        }</span>
        <span class="cov0" title="0">ts, ok := decl.(*ast.TypeSpec)
        if !ok </span><span class="cov0" title="0">{
                return ""
        }</span>
        <span class="cov0" title="0">if ts.TypeParams == nil || len(ts.TypeParams.List) == 0 </span><span class="cov0" title="0">{
                return ""
        }</span>
        <span class="cov0" title="0">var sb strings.Builder
        sb.WriteString("[")
        for i, v := range ts.TypeParams.List </span><span class="cov0" title="0">{
                if i != 0 </span><span class="cov0" title="0">{
                        sb.WriteString(", ")
                }</span>
                <span class="cov0" title="0">sb.WriteString(v.Names[0].Name)</span>
        }
        <span class="cov0" title="0">sb.WriteString("]")
        return sb.String()</span>
}
</pre>
		
		<pre class="file" id="file6" style="display: none">package bugreport

//go:generate mockgen -aux_files faux=faux/faux.go -destination bugreport_mock.go -package bugreport -source=bugreport.go Example

import (
        "log"

        "github.com/golang/mock/mockgen/internal/tests/aux_imports_embedded_interface/faux"
)

// Source is an interface w/ an embedded foreign interface
type Source interface {
        faux.Foreign
}

func CallForeignMethod(s Source) <span class="cov8" title="1">{
        log.Println(s.Method())
}</span>
</pre>
		
		<pre class="file" id="file7" style="display: none">// Code generated by MockGen. DO NOT EDIT.
// Source: bugreport.go

// Package bugreport is a generated GoMock package.
package bugreport

import (
        reflect "reflect"

        gomock "github.com/golang/mock/gomock"
        faux "github.com/golang/mock/mockgen/internal/tests/aux_imports_embedded_interface/faux"
)

// MockSource is a mock of Source interface.
type MockSource struct {
        ctrl     *gomock.Controller
        recorder *MockSourceMockRecorder
}

// MockSourceMockRecorder is the mock recorder for MockSource.
type MockSourceMockRecorder struct {
        mock *MockSource
}

// NewMockSource creates a new mock instance.
func NewMockSource(ctrl *gomock.Controller) *MockSource <span class="cov8" title="1">{
        mock := &amp;MockSource{ctrl: ctrl}
        mock.recorder = &amp;MockSourceMockRecorder{mock}
        return mock
}</span>

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockSource) EXPECT() *MockSourceMockRecorder <span class="cov8" title="1">{
        return m.recorder
}</span>

// Error mocks base method.
func (m *MockSource) Error() string <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Error")
        ret0, _ := ret[0].(string)
        return ret0
}</span>

// Error indicates an expected call of Error.
func (mr *MockSourceMockRecorder) Error() *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Error", reflect.TypeOf((*MockSource)(nil).Error))
}</span>

// Method mocks base method.
func (m *MockSource) Method() faux.Return <span class="cov8" title="1">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Method")
        ret0, _ := ret[0].(faux.Return)
        return ret0
}</span>

// Method indicates an expected call of Method.
func (mr *MockSourceMockRecorder) Method() *gomock.Call <span class="cov8" title="1">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Method", reflect.TypeOf((*MockSource)(nil).Method))
}</span>
</pre>
		
		<pre class="file" id="file8" style="display: none">// Code generated by MockGen. DO NOT EDIT.
// Source: input.go

// Package const_length is a generated GoMock package.
package const_length

import (
        reflect "reflect"

        gomock "github.com/golang/mock/gomock"
)

// MockI is a mock of I interface.
type MockI struct {
        ctrl     *gomock.Controller
        recorder *MockIMockRecorder
}

// MockIMockRecorder is the mock recorder for MockI.
type MockIMockRecorder struct {
        mock *MockI
}

// NewMockI creates a new mock instance.
func NewMockI(ctrl *gomock.Controller) *MockI <span class="cov0" title="0">{
        mock := &amp;MockI{ctrl: ctrl}
        mock.recorder = &amp;MockIMockRecorder{mock}
        return mock
}</span>

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockI) EXPECT() *MockIMockRecorder <span class="cov0" title="0">{
        return m.recorder
}</span>

// Bar mocks base method.
func (m *MockI) Bar() [2]int <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Bar")
        ret0, _ := ret[0].([2]int)
        return ret0
}</span>

// Bar indicates an expected call of Bar.
func (mr *MockIMockRecorder) Bar() *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Bar", reflect.TypeOf((*MockI)(nil).Bar))
}</span>

// Baz mocks base method.
func (m *MockI) Baz() [127]int <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Baz")
        ret0, _ := ret[0].([127]int)
        return ret0
}</span>

// Baz indicates an expected call of Baz.
func (mr *MockIMockRecorder) Baz() *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Baz", reflect.TypeOf((*MockI)(nil).Baz))
}</span>

// Corge mocks base method.
func (m *MockI) Corge() [7]int <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Corge")
        ret0, _ := ret[0].([7]int)
        return ret0
}</span>

// Corge indicates an expected call of Corge.
func (mr *MockIMockRecorder) Corge() *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Corge", reflect.TypeOf((*MockI)(nil).Corge))
}</span>

// Foo mocks base method.
func (m *MockI) Foo() [2]int <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Foo")
        ret0, _ := ret[0].([2]int)
        return ret0
}</span>

// Foo indicates an expected call of Foo.
func (mr *MockIMockRecorder) Foo() *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Foo", reflect.TypeOf((*MockI)(nil).Foo))
}</span>

// Quux mocks base method.
func (m *MockI) Quux() [3]int <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Quux")
        ret0, _ := ret[0].([3]int)
        return ret0
}</span>

// Quux indicates an expected call of Quux.
func (mr *MockIMockRecorder) Quux() *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Quux", reflect.TypeOf((*MockI)(nil).Quux))
}</span>

// Qux mocks base method.
func (m *MockI) Qux() [3]int <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Qux")
        ret0, _ := ret[0].([3]int)
        return ret0
}</span>

// Qux indicates an expected call of Qux.
func (mr *MockIMockRecorder) Qux() *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Qux", reflect.TypeOf((*MockI)(nil).Qux))
}</span>
</pre>
		
		<pre class="file" id="file9" style="display: none">// This is a mock copyright header.
//
// Lorem ipsum dolor sit amet, consectetur adipiscing elit,
// sed do eiusmod tempor incididunt ut labore et dolore magna
// aliqua. Velit ut tortor pretium viverra suspendisse potenti.
//

// Code generated by MockGen. DO NOT EDIT.
// Source: input.go

// Package empty_interface is a generated GoMock package.
package empty_interface

import (
        gomock "github.com/golang/mock/gomock"
)

// MockEmpty is a mock of Empty interface.
type MockEmpty struct {
        ctrl     *gomock.Controller
        recorder *MockEmptyMockRecorder
}

// MockEmptyMockRecorder is the mock recorder for MockEmpty.
type MockEmptyMockRecorder struct {
        mock *MockEmpty
}

// NewMockEmpty creates a new mock instance.
func NewMockEmpty(ctrl *gomock.Controller) *MockEmpty <span class="cov0" title="0">{
        mock := &amp;MockEmpty{ctrl: ctrl}
        mock.recorder = &amp;MockEmptyMockRecorder{mock}
        return mock
}</span>

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockEmpty) EXPECT() *MockEmptyMockRecorder <span class="cov0" title="0">{
        return m.recorder
}</span>
</pre>
		
		<pre class="file" id="file10" style="display: none">package client

import "fmt"

type Client struct{}

func (c *Client) Greet(in GreetInput) string <span class="cov8" title="1">{
        return fmt.Sprintf("Hello, %s!", in.Name)
}</span>

type GreetInput struct {
        Name string
}
</pre>
		
		<pre class="file" id="file11" style="display: none">package greeter

//go:generate mockgen -source greeter.go -destination greeter_mock_test.go -package greeter

import (
        // stdlib import
        "fmt"

        // non-matching import suffix and package name
        "github.com/golang/mock/mockgen/internal/tests/custom_package_name/client/v1"

        //  matching import suffix and package name
        "github.com/golang/mock/mockgen/internal/tests/custom_package_name/validator"
)

type InputMaker interface {
        MakeInput() client.GreetInput
}

type Greeter struct {
        InputMaker InputMaker
        Client     *client.Client
}

func (g *Greeter) Greet() (string, error) <span class="cov8" title="1">{
        in := g.InputMaker.MakeInput()
        if err := validator.Validate(in.Name); err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("validation failed: %v", err)
        }</span>
        <span class="cov8" title="1">return g.Client.Greet(in), nil</span>
}
</pre>
		
		<pre class="file" id="file12" style="display: none">package validator

func Validate(s string) error <span class="cov8" title="1">{
        return nil
}</span>
</pre>
		
		<pre class="file" id="file13" style="display: none">// Code generated by MockGen. DO NOT EDIT.
// Source: input.go

// Package dot_imports is a generated GoMock package.
package dot_imports

import (
        bytes "bytes"
        . "context"
        . "net/http"
        reflect "reflect"

        gomock "github.com/golang/mock/gomock"
)

// MockWithDotImports is a mock of WithDotImports interface.
type MockWithDotImports struct {
        ctrl     *gomock.Controller
        recorder *MockWithDotImportsMockRecorder
}

// MockWithDotImportsMockRecorder is the mock recorder for MockWithDotImports.
type MockWithDotImportsMockRecorder struct {
        mock *MockWithDotImports
}

// NewMockWithDotImports creates a new mock instance.
func NewMockWithDotImports(ctrl *gomock.Controller) *MockWithDotImports <span class="cov0" title="0">{
        mock := &amp;MockWithDotImports{ctrl: ctrl}
        mock.recorder = &amp;MockWithDotImportsMockRecorder{mock}
        return mock
}</span>

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockWithDotImports) EXPECT() *MockWithDotImportsMockRecorder <span class="cov0" title="0">{
        return m.recorder
}</span>

// Method1 mocks base method.
func (m *MockWithDotImports) Method1() Request <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Method1")
        ret0, _ := ret[0].(Request)
        return ret0
}</span>

// Method1 indicates an expected call of Method1.
func (mr *MockWithDotImportsMockRecorder) Method1() *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Method1", reflect.TypeOf((*MockWithDotImports)(nil).Method1))
}</span>

// Method2 mocks base method.
func (m *MockWithDotImports) Method2() *bytes.Buffer <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Method2")
        ret0, _ := ret[0].(*bytes.Buffer)
        return ret0
}</span>

// Method2 indicates an expected call of Method2.
func (mr *MockWithDotImportsMockRecorder) Method2() *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Method2", reflect.TypeOf((*MockWithDotImports)(nil).Method2))
}</span>

// Method3 mocks base method.
func (m *MockWithDotImports) Method3() Context <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Method3")
        ret0, _ := ret[0].(Context)
        return ret0
}</span>

// Method3 indicates an expected call of Method3.
func (mr *MockWithDotImportsMockRecorder) Method3() *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Method3", reflect.TypeOf((*MockWithDotImports)(nil).Method3))
}</span>
</pre>
		
		<pre class="file" id="file14" style="display: none">// Code generated by MockGen. DO NOT EDIT.
// Source: input.go

// Package empty_interface is a generated GoMock package.
package empty_interface

import (
        gomock "github.com/golang/mock/gomock"
)

// MockEmpty is a mock of Empty interface.
type MockEmpty struct {
        ctrl     *gomock.Controller
        recorder *MockEmptyMockRecorder
}

// MockEmptyMockRecorder is the mock recorder for MockEmpty.
type MockEmptyMockRecorder struct {
        mock *MockEmpty
}

// NewMockEmpty creates a new mock instance.
func NewMockEmpty(ctrl *gomock.Controller) *MockEmpty <span class="cov0" title="0">{
        mock := &amp;MockEmpty{ctrl: ctrl}
        mock.recorder = &amp;MockEmptyMockRecorder{mock}
        return mock
}</span>

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockEmpty) EXPECT() *MockEmptyMockRecorder <span class="cov0" title="0">{
        return m.recorder
}</span>
</pre>
		
		<pre class="file" id="file15" style="display: none">// Code generated by MockGen. DO NOT EDIT.
// Source: github.com/golang/mock/mockgen/internal/tests/extra_import (interfaces: Foo)

// Package extra_import is a generated GoMock package.
package extra_import

import (
        reflect "reflect"

        gomock "github.com/golang/mock/gomock"
)

// MockFoo is a mock of Foo interface.
type MockFoo struct {
        ctrl     *gomock.Controller
        recorder *MockFooMockRecorder
}

// MockFooMockRecorder is the mock recorder for MockFoo.
type MockFooMockRecorder struct {
        mock *MockFoo
}

// NewMockFoo creates a new mock instance.
func NewMockFoo(ctrl *gomock.Controller) *MockFoo <span class="cov0" title="0">{
        mock := &amp;MockFoo{ctrl: ctrl}
        mock.recorder = &amp;MockFooMockRecorder{mock}
        return mock
}</span>

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockFoo) EXPECT() *MockFooMockRecorder <span class="cov0" title="0">{
        return m.recorder
}</span>

// Bar mocks base method.
func (m *MockFoo) Bar(arg0 []string, arg1 chan&lt;- Message) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        m.ctrl.Call(m, "Bar", arg0, arg1)
}</span>

// Bar indicates an expected call of Bar.
func (mr *MockFooMockRecorder) Bar(arg0, arg1 interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Bar", reflect.TypeOf((*MockFoo)(nil).Bar), arg0, arg1)
}</span>
</pre>
		
		<pre class="file" id="file16" style="display: none">// Code generated by MockGen. DO NOT EDIT.
// Source: bugreport.go

// Package bugreport is a generated GoMock package.
package bugreport

import (
        reflect "reflect"

        gomock "github.com/golang/mock/gomock"
)

// MockExample is a mock of Example interface.
type MockExample struct {
        ctrl     *gomock.Controller
        recorder *MockExampleMockRecorder
}

// MockExampleMockRecorder is the mock recorder for MockExample.
type MockExampleMockRecorder struct {
        mock *MockExample
}

// NewMockExample creates a new mock instance.
func NewMockExample(ctrl *gomock.Controller) *MockExample <span class="cov8" title="1">{
        mock := &amp;MockExample{ctrl: ctrl}
        mock.recorder = &amp;MockExampleMockRecorder{mock}
        return mock
}</span>

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockExample) EXPECT() *MockExampleMockRecorder <span class="cov8" title="1">{
        return m.recorder
}</span>

// Method mocks base method.
func (m_2 *MockExample) Method(_m, _mr, m, mr int) <span class="cov8" title="1">{
        m_2.ctrl.T.Helper()
        m_2.ctrl.Call(m_2, "Method", _m, _mr, m, mr)
}</span>

// Method indicates an expected call of Method.
func (mr_2 *MockExampleMockRecorder) Method(_m, _mr, m, mr interface{}) *gomock.Call <span class="cov8" title="1">{
        mr_2.mock.ctrl.T.Helper()
        return mr_2.mock.ctrl.RecordCallWithMethodType(mr_2.mock, "Method", reflect.TypeOf((*MockExample)(nil).Method), _m, _mr, m, mr)
}</span>

// VarargMethod mocks base method.
func (m *MockExample) VarargMethod(_s, _x, a, ret int, varargs ...int) <span class="cov8" title="1">{
        m.ctrl.T.Helper()
        varargs_2 := []interface{}{_s, _x, a, ret}
        for _, a_2 := range varargs </span><span class="cov8" title="1">{
                varargs_2 = append(varargs_2, a_2)
        }</span>
        <span class="cov8" title="1">m.ctrl.Call(m, "VarargMethod", varargs_2...)</span>
}

// VarargMethod indicates an expected call of VarargMethod.
func (mr *MockExampleMockRecorder) VarargMethod(_s, _x, a, ret interface{}, varargs ...interface{}) *gomock.Call <span class="cov8" title="1">{
        mr.mock.ctrl.T.Helper()
        varargs_2 := append([]interface{}{_s, _x, a, ret}, varargs...)
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "VarargMethod", reflect.TypeOf((*MockExample)(nil).VarargMethod), varargs_2...)
}</span>
</pre>
		
		<pre class="file" id="file17" style="display: none">// Copyright 2020 Google Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package bugreport

//go:generate mockgen -destination bugreport_mock.go -package bugreport -source=bugreport.go

import (
        "log"

        "github.com/golang/mock/mockgen/internal/tests/import_embedded_interface/ersatz"
        "github.com/golang/mock/mockgen/internal/tests/import_embedded_interface/faux"
)

// Source is an interface w/ an embedded foreign interface
type Source interface {
        ersatz.Embedded
        faux.Foreign
        error
        Foo
}

func CallForeignMethod(s Source) <span class="cov8" title="1">{
        log.Println(s.Ersatz())
        log.Println(s.OtherErsatz())
}</span>
</pre>
		
		<pre class="file" id="file18" style="display: none">// Code generated by MockGen. DO NOT EDIT.
// Source: bugreport.go

// Package bugreport is a generated GoMock package.
package bugreport

import (
        reflect "reflect"

        gomock "github.com/golang/mock/gomock"
        ersatz "github.com/golang/mock/mockgen/internal/tests/import_embedded_interface/ersatz"
        ersatz0 "github.com/golang/mock/mockgen/internal/tests/import_embedded_interface/other/ersatz"
)

// MockSource is a mock of Source interface.
type MockSource struct {
        ctrl     *gomock.Controller
        recorder *MockSourceMockRecorder
}

// MockSourceMockRecorder is the mock recorder for MockSource.
type MockSourceMockRecorder struct {
        mock *MockSource
}

// NewMockSource creates a new mock instance.
func NewMockSource(ctrl *gomock.Controller) *MockSource <span class="cov8" title="1">{
        mock := &amp;MockSource{ctrl: ctrl}
        mock.recorder = &amp;MockSourceMockRecorder{mock}
        return mock
}</span>

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockSource) EXPECT() *MockSourceMockRecorder <span class="cov8" title="1">{
        return m.recorder
}</span>

// Bar mocks base method.
func (m *MockSource) Bar() Baz <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Bar")
        ret0, _ := ret[0].(Baz)
        return ret0
}</span>

// Bar indicates an expected call of Bar.
func (mr *MockSourceMockRecorder) Bar() *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Bar", reflect.TypeOf((*MockSource)(nil).Bar))
}</span>

// Error mocks base method.
func (m *MockSource) Error() string <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Error")
        ret0, _ := ret[0].(string)
        return ret0
}</span>

// Error indicates an expected call of Error.
func (mr *MockSourceMockRecorder) Error() *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Error", reflect.TypeOf((*MockSource)(nil).Error))
}</span>

// Ersatz mocks base method.
func (m *MockSource) Ersatz() ersatz.Return <span class="cov8" title="1">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Ersatz")
        ret0, _ := ret[0].(ersatz.Return)
        return ret0
}</span>

// Ersatz indicates an expected call of Ersatz.
func (mr *MockSourceMockRecorder) Ersatz() *gomock.Call <span class="cov8" title="1">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Ersatz", reflect.TypeOf((*MockSource)(nil).Ersatz))
}</span>

// OtherErsatz mocks base method.
func (m *MockSource) OtherErsatz() ersatz0.Return <span class="cov8" title="1">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "OtherErsatz")
        ret0, _ := ret[0].(ersatz0.Return)
        return ret0
}</span>

// OtherErsatz indicates an expected call of OtherErsatz.
func (mr *MockSourceMockRecorder) OtherErsatz() *gomock.Call <span class="cov8" title="1">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "OtherErsatz", reflect.TypeOf((*MockSource)(nil).OtherErsatz))
}</span>
</pre>
		
		<pre class="file" id="file19" style="display: none">// Copyright 2020 Google Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
package faux

import "github.com/golang/mock/mockgen/internal/tests/import_embedded_interface/other/log"

func Conflict1() <span class="cov0" title="0">{
        log.Foo()
}</span>
</pre>
		
		<pre class="file" id="file20" style="display: none">// Copyright 2020 Google Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
package faux

import (
        "log"

        "github.com/golang/mock/mockgen/internal/tests/import_embedded_interface/other/ersatz"
)

type Foreign interface {
        ersatz.Embedded
}

func Conflict0() <span class="cov0" title="0">{
        log.Println()
}</span>
</pre>
		
		<pre class="file" id="file21" style="display: none">//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package bugreport

//go:generate mockgen -destination net_mock.go -package bugreport -source=net.go

import "net/http"

type Net interface {
        http.ResponseWriter
}

func CallResponseWriterMethods(n Net) <span class="cov8" title="1">{
        n.WriteHeader(10)
}</span>
</pre>
		
		<pre class="file" id="file22" style="display: none">// Code generated by MockGen. DO NOT EDIT.
// Source: net.go

// Package bugreport is a generated GoMock package.
package bugreport

import (
        http "net/http"
        reflect "reflect"

        gomock "github.com/golang/mock/gomock"
)

// MockNet is a mock of Net interface.
type MockNet struct {
        ctrl     *gomock.Controller
        recorder *MockNetMockRecorder
}

// MockNetMockRecorder is the mock recorder for MockNet.
type MockNetMockRecorder struct {
        mock *MockNet
}

// NewMockNet creates a new mock instance.
func NewMockNet(ctrl *gomock.Controller) *MockNet <span class="cov8" title="1">{
        mock := &amp;MockNet{ctrl: ctrl}
        mock.recorder = &amp;MockNetMockRecorder{mock}
        return mock
}</span>

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockNet) EXPECT() *MockNetMockRecorder <span class="cov8" title="1">{
        return m.recorder
}</span>

// Header mocks base method.
func (m *MockNet) Header() http.Header <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Header")
        ret0, _ := ret[0].(http.Header)
        return ret0
}</span>

// Header indicates an expected call of Header.
func (mr *MockNetMockRecorder) Header() *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Header", reflect.TypeOf((*MockNet)(nil).Header))
}</span>

// Write mocks base method.
func (m *MockNet) Write(arg0 []byte) (int, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Write", arg0)
        ret0, _ := ret[0].(int)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// Write indicates an expected call of Write.
func (mr *MockNetMockRecorder) Write(arg0 interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Write", reflect.TypeOf((*MockNet)(nil).Write), arg0)
}</span>

// WriteHeader mocks base method.
func (m *MockNet) WriteHeader(statusCode int) <span class="cov8" title="1">{
        m.ctrl.T.Helper()
        m.ctrl.Call(m, "WriteHeader", statusCode)
}</span>

// WriteHeader indicates an expected call of WriteHeader.
func (mr *MockNetMockRecorder) WriteHeader(statusCode interface{}) *gomock.Call <span class="cov8" title="1">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "WriteHeader", reflect.TypeOf((*MockNet)(nil).WriteHeader), statusCode)
}</span>
</pre>
		
		<pre class="file" id="file23" style="display: none">// Copyright 2020 Google Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
package log

func Foo() {<span class="cov0" title="0">}</span>
</pre>
		
		<pre class="file" id="file24" style="display: none">// Code generated by MockGen. DO NOT EDIT.
// Source: source.go

// Package source is a generated GoMock package.
package source

import (
        reflect "reflect"

        gomock "github.com/golang/mock/gomock"
)

// MockS is a mock of S interface.
type MockS struct {
        ctrl     *gomock.Controller
        recorder *MockSMockRecorder
}

// MockSMockRecorder is the mock recorder for MockS.
type MockSMockRecorder struct {
        mock *MockS
}

// NewMockS creates a new mock instance.
func NewMockS(ctrl *gomock.Controller) *MockS <span class="cov0" title="0">{
        mock := &amp;MockS{ctrl: ctrl}
        mock.recorder = &amp;MockSMockRecorder{mock}
        return mock
}</span>

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockS) EXPECT() *MockSMockRecorder <span class="cov0" title="0">{
        return m.recorder
}</span>

// F mocks base method.
func (m *MockS) F(arg0 X) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        m.ctrl.Call(m, "F", arg0)
}</span>

// F indicates an expected call of F.
func (mr *MockSMockRecorder) F(arg0 interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "F", reflect.TypeOf((*MockS)(nil).F), arg0)
}</span>
</pre>
		
		<pre class="file" id="file25" style="display: none">// Code generated by MockGen. DO NOT EDIT.
// Source: source.go

// Package mock_source is a generated GoMock package.
package mock_source

import (
        reflect "reflect"

        gomock "github.com/golang/mock/gomock"
        source "github.com/golang/mock/mockgen/internal/tests/import_source/definition"
)

// MockS is a mock of S interface.
type MockS struct {
        ctrl     *gomock.Controller
        recorder *MockSMockRecorder
}

// MockSMockRecorder is the mock recorder for MockS.
type MockSMockRecorder struct {
        mock *MockS
}

// NewMockS creates a new mock instance.
func NewMockS(ctrl *gomock.Controller) *MockS <span class="cov0" title="0">{
        mock := &amp;MockS{ctrl: ctrl}
        mock.recorder = &amp;MockSMockRecorder{mock}
        return mock
}</span>

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockS) EXPECT() *MockSMockRecorder <span class="cov0" title="0">{
        return m.recorder
}</span>

// F mocks base method.
func (m *MockS) F(arg0 source.X) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        m.ctrl.Call(m, "F", arg0)
}</span>

// F indicates an expected call of F.
func (mr *MockSMockRecorder) F(arg0 interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "F", reflect.TypeOf((*MockS)(nil).F), arg0)
}</span>
</pre>
		
		<pre class="file" id="file26" style="display: none">// Code generated by MockGen. DO NOT EDIT.
// Source: github.com/golang/mock/mockgen/internal/tests/internal_pkg/subdir/internal/pkg (interfaces: Intf)

// Package mock_pkg is a generated GoMock package.
package mock_pkg

import (
        reflect "reflect"

        gomock "github.com/golang/mock/gomock"
        pkg "github.com/golang/mock/mockgen/internal/tests/internal_pkg/subdir/internal/pkg"
)

// MockIntf is a mock of Intf interface.
type MockIntf struct {
        ctrl     *gomock.Controller
        recorder *MockIntfMockRecorder
}

// MockIntfMockRecorder is the mock recorder for MockIntf.
type MockIntfMockRecorder struct {
        mock *MockIntf
}

// NewMockIntf creates a new mock instance.
func NewMockIntf(ctrl *gomock.Controller) *MockIntf <span class="cov0" title="0">{
        mock := &amp;MockIntf{ctrl: ctrl}
        mock.recorder = &amp;MockIntfMockRecorder{mock}
        return mock
}</span>

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockIntf) EXPECT() *MockIntfMockRecorder <span class="cov0" title="0">{
        return m.recorder
}</span>

// F mocks base method.
func (m *MockIntf) F() pkg.Arg <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "F")
        ret0, _ := ret[0].(pkg.Arg)
        return ret0
}</span>

// F indicates an expected call of F.
func (mr *MockIntfMockRecorder) F() *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "F", reflect.TypeOf((*MockIntf)(nil).F))
}</span>
</pre>
		
		<pre class="file" id="file27" style="display: none">// Code generated by MockGen. DO NOT EDIT.
// Source: subdir/internal/pkg/input.go

// Package mock_pkg is a generated GoMock package.
package mock_pkg

import (
        reflect "reflect"

        gomock "github.com/golang/mock/gomock"
        pkg "github.com/golang/mock/mockgen/internal/tests/internal_pkg/subdir/internal/pkg"
)

// MockArg is a mock of Arg interface.
type MockArg struct {
        ctrl     *gomock.Controller
        recorder *MockArgMockRecorder
}

// MockArgMockRecorder is the mock recorder for MockArg.
type MockArgMockRecorder struct {
        mock *MockArg
}

// NewMockArg creates a new mock instance.
func NewMockArg(ctrl *gomock.Controller) *MockArg <span class="cov0" title="0">{
        mock := &amp;MockArg{ctrl: ctrl}
        mock.recorder = &amp;MockArgMockRecorder{mock}
        return mock
}</span>

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockArg) EXPECT() *MockArgMockRecorder <span class="cov0" title="0">{
        return m.recorder
}</span>

// Foo mocks base method.
func (m *MockArg) Foo() int <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Foo")
        ret0, _ := ret[0].(int)
        return ret0
}</span>

// Foo indicates an expected call of Foo.
func (mr *MockArgMockRecorder) Foo() *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Foo", reflect.TypeOf((*MockArg)(nil).Foo))
}</span>

// MockIntf is a mock of Intf interface.
type MockIntf struct {
        ctrl     *gomock.Controller
        recorder *MockIntfMockRecorder
}

// MockIntfMockRecorder is the mock recorder for MockIntf.
type MockIntfMockRecorder struct {
        mock *MockIntf
}

// NewMockIntf creates a new mock instance.
func NewMockIntf(ctrl *gomock.Controller) *MockIntf <span class="cov0" title="0">{
        mock := &amp;MockIntf{ctrl: ctrl}
        mock.recorder = &amp;MockIntfMockRecorder{mock}
        return mock
}</span>

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockIntf) EXPECT() *MockIntfMockRecorder <span class="cov0" title="0">{
        return m.recorder
}</span>

// F mocks base method.
func (m *MockIntf) F() pkg.Arg <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "F")
        ret0, _ := ret[0].(pkg.Arg)
        return ret0
}</span>

// F indicates an expected call of F.
func (mr *MockIntfMockRecorder) F() *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "F", reflect.TypeOf((*MockIntf)(nil).F))
}</span>
</pre>
		
		<pre class="file" id="file28" style="display: none">// Code generated by MockGen. DO NOT EDIT.
// Source: source.go

// Package source is a generated GoMock package.
package source

import (
        reflect "reflect"

        gomock "github.com/golang/mock/gomock"
        source "github.com/golang/mock/mockgen/internal/tests/missing_import/source"
)

// MockBar is a mock of Bar interface.
type MockBar struct {
        ctrl     *gomock.Controller
        recorder *MockBarMockRecorder
}

// MockBarMockRecorder is the mock recorder for MockBar.
type MockBarMockRecorder struct {
        mock *MockBar
}

// NewMockBar creates a new mock instance.
func NewMockBar(ctrl *gomock.Controller) *MockBar <span class="cov0" title="0">{
        mock := &amp;MockBar{ctrl: ctrl}
        mock.recorder = &amp;MockBarMockRecorder{mock}
        return mock
}</span>

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockBar) EXPECT() *MockBarMockRecorder <span class="cov0" title="0">{
        return m.recorder
}</span>

// Baz mocks base method.
func (m *MockBar) Baz(arg0 source.Foo) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        m.ctrl.Call(m, "Baz", arg0)
}</span>

// Baz indicates an expected call of Baz.
func (mr *MockBarMockRecorder) Baz(arg0 interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Baz", reflect.TypeOf((*MockBar)(nil).Baz), arg0)
}</span>
</pre>
		
		<pre class="file" id="file29" style="display: none">// Code generated by MockGen. DO NOT EDIT.
// Source: overlap.go

// Package overlap is a generated GoMock package.
package overlap

import (
        reflect "reflect"

        gomock "github.com/golang/mock/gomock"
)

// MockReadWriteCloser is a mock of ReadWriteCloser interface.
type MockReadWriteCloser struct {
        ctrl     *gomock.Controller
        recorder *MockReadWriteCloserMockRecorder
}

// MockReadWriteCloserMockRecorder is the mock recorder for MockReadWriteCloser.
type MockReadWriteCloserMockRecorder struct {
        mock *MockReadWriteCloser
}

// NewMockReadWriteCloser creates a new mock instance.
func NewMockReadWriteCloser(ctrl *gomock.Controller) *MockReadWriteCloser <span class="cov8" title="1">{
        mock := &amp;MockReadWriteCloser{ctrl: ctrl}
        mock.recorder = &amp;MockReadWriteCloserMockRecorder{mock}
        return mock
}</span>

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockReadWriteCloser) EXPECT() *MockReadWriteCloserMockRecorder <span class="cov8" title="1">{
        return m.recorder
}</span>

// Close mocks base method.
func (m *MockReadWriteCloser) Close() error <span class="cov8" title="1">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Close")
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// Close indicates an expected call of Close.
func (mr *MockReadWriteCloserMockRecorder) Close() *gomock.Call <span class="cov8" title="1">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Close", reflect.TypeOf((*MockReadWriteCloser)(nil).Close))
}</span>

// Read mocks base method.
func (m *MockReadWriteCloser) Read(arg0 []byte) (int, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Read", arg0)
        ret0, _ := ret[0].(int)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// Read indicates an expected call of Read.
func (mr *MockReadWriteCloserMockRecorder) Read(arg0 interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Read", reflect.TypeOf((*MockReadWriteCloser)(nil).Read), arg0)
}</span>

// Write mocks base method.
func (m *MockReadWriteCloser) Write(arg0 []byte) (int, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Write", arg0)
        ret0, _ := ret[0].(int)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// Write indicates an expected call of Write.
func (mr *MockReadWriteCloserMockRecorder) Write(arg0 interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Write", reflect.TypeOf((*MockReadWriteCloser)(nil).Write), arg0)
}</span>
</pre>
		
		<pre class="file" id="file30" style="display: none">// Copyright 2020 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package paniccode

//go:generate mockgen --source=panic.go --destination=mock_test.go --package=paniccode

type Foo interface {
        Bar() string
        Baz() string
}

func Danger(f Foo) <span class="cov0" title="0">{
        if f.Bar() == "Bar" </span><span class="cov0" title="0">{
                panic("Danger, Will Robinson!")</span>
        }
}
</pre>
		
		<pre class="file" id="file31" style="display: none">// Code generated by MockGen. DO NOT EDIT.
// Source: ./mockgen/internal/tests/parenthesized_parameter_type/input.go

// Package parenthesized_parameter_type is a generated GoMock package.
package parenthesized_parameter_type

import (
        gomock "github.com/golang/mock/gomock"
        reflect "reflect"
)

// MockExample is a mock of Example interface.
type MockExample struct {
        ctrl     *gomock.Controller
        recorder *MockExampleMockRecorder
}

// MockExampleMockRecorder is the mock recorder for MockExample.
type MockExampleMockRecorder struct {
        mock *MockExample
}

// NewMockExample creates a new mock instance.
func NewMockExample(ctrl *gomock.Controller) *MockExample <span class="cov0" title="0">{
        mock := &amp;MockExample{ctrl: ctrl}
        mock.recorder = &amp;MockExampleMockRecorder{mock}
        return mock
}</span>

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockExample) EXPECT() *MockExampleMockRecorder <span class="cov0" title="0">{
        return m.recorder
}</span>

// ParenthesizedParameterType mocks base method.
func (m *MockExample) ParenthesizedParameterType(param *int) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        m.ctrl.Call(m, "ParenthesizedParameterType", param)
}</span>

// ParenthesizedParameterType indicates an expected call of ParenthesizedParameterType.
func (mr *MockExampleMockRecorder) ParenthesizedParameterType(param interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ParenthesizedParameterType", reflect.TypeOf((*MockExample)(nil).ParenthesizedParameterType), param)
}</span>
</pre>
		
		<pre class="file" id="file32" style="display: none">// Code generated by MockGen. DO NOT EDIT.
// Source: github.com/golang/mock/mockgen/internal/tests/self_package (interfaces: Methods)

// Package core is a generated GoMock package.
package core

import (
        reflect "reflect"

        gomock "github.com/golang/mock/gomock"
)

// MockMethods is a mock of Methods interface.
type MockMethods struct {
        ctrl     *gomock.Controller
        recorder *MockMethodsMockRecorder
}

// MockMethodsMockRecorder is the mock recorder for MockMethods.
type MockMethodsMockRecorder struct {
        mock *MockMethods
}

// NewMockMethods creates a new mock instance.
func NewMockMethods(ctrl *gomock.Controller) *MockMethods <span class="cov0" title="0">{
        mock := &amp;MockMethods{ctrl: ctrl}
        mock.recorder = &amp;MockMethodsMockRecorder{mock}
        return mock
}</span>

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockMethods) EXPECT() *MockMethodsMockRecorder <span class="cov0" title="0">{
        return m.recorder
}</span>

// getInfo mocks base method.
func (m *MockMethods) getInfo() Info <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "getInfo")
        ret0, _ := ret[0].(Info)
        return ret0
}</span>

// getInfo indicates an expected call of getInfo.
func (mr *MockMethodsMockRecorder) getInfo() *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "getInfo", reflect.TypeOf((*MockMethods)(nil).getInfo))
}</span>
</pre>
		
		<pre class="file" id="file33" style="display: none">package bugreport

//go:generate mockgen -destination bugreport_mock.go -package bugreport -source=bugreport.go Example

import "fmt"

// Example is an interface with a non exported method
type Example interface {
        someMethod(string) string
}

// CallExample is a simple function that uses the interface
func CallExample(e Example) <span class="cov8" title="1">{
        fmt.Println(e.someMethod("test"))
}</span>
</pre>
		
		<pre class="file" id="file34" style="display: none">// Code generated by MockGen. DO NOT EDIT.
// Source: bugreport.go

// Package bugreport is a generated GoMock package.
package bugreport

import (
        reflect "reflect"

        gomock "github.com/golang/mock/gomock"
)

// MockExample is a mock of Example interface.
type MockExample struct {
        ctrl     *gomock.Controller
        recorder *MockExampleMockRecorder
}

// MockExampleMockRecorder is the mock recorder for MockExample.
type MockExampleMockRecorder struct {
        mock *MockExample
}

// NewMockExample creates a new mock instance.
func NewMockExample(ctrl *gomock.Controller) *MockExample <span class="cov8" title="1">{
        mock := &amp;MockExample{ctrl: ctrl}
        mock.recorder = &amp;MockExampleMockRecorder{mock}
        return mock
}</span>

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockExample) EXPECT() *MockExampleMockRecorder <span class="cov8" title="1">{
        return m.recorder
}</span>

// someMethod mocks base method.
func (m *MockExample) someMethod(arg0 string) string <span class="cov8" title="1">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "someMethod", arg0)
        ret0, _ := ret[0].(string)
        return ret0
}</span>

// someMethod indicates an expected call of someMethod.
func (mr *MockExampleMockRecorder) someMethod(arg0 interface{}) *gomock.Call <span class="cov8" title="1">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "someMethod", reflect.TypeOf((*MockExample)(nil).someMethod), arg0)
}</span>
</pre>
		
		<pre class="file" id="file35" style="display: none">// Code generated by MockGen. DO NOT EDIT.
// Source: github.com/golang/mock/mockgen/internal/tests/vendor_dep (interfaces: VendorsDep)

// Package vendor_dep is a generated GoMock package.
package vendor_dep

import (
        reflect "reflect"

        gomock "github.com/golang/mock/gomock"
        present "golang.org/x/tools/present"
)

// MockVendorsDep is a mock of VendorsDep interface.
type MockVendorsDep struct {
        ctrl     *gomock.Controller
        recorder *MockVendorsDepMockRecorder
}

// MockVendorsDepMockRecorder is the mock recorder for MockVendorsDep.
type MockVendorsDepMockRecorder struct {
        mock *MockVendorsDep
}

// NewMockVendorsDep creates a new mock instance.
func NewMockVendorsDep(ctrl *gomock.Controller) *MockVendorsDep <span class="cov0" title="0">{
        mock := &amp;MockVendorsDep{ctrl: ctrl}
        mock.recorder = &amp;MockVendorsDepMockRecorder{mock}
        return mock
}</span>

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockVendorsDep) EXPECT() *MockVendorsDepMockRecorder <span class="cov0" title="0">{
        return m.recorder
}</span>

// Foo mocks base method.
func (m *MockVendorsDep) Foo() present.Elem <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Foo")
        ret0, _ := ret[0].(present.Elem)
        return ret0
}</span>

// Foo indicates an expected call of Foo.
func (mr *MockVendorsDepMockRecorder) Foo() *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Foo", reflect.TypeOf((*MockVendorsDep)(nil).Foo))
}</span>
</pre>
		
		<pre class="file" id="file36" style="display: none">// Code generated by MockGen. DO NOT EDIT.
// Source: vendor_dep.go

// Package mock_vendor_dep is a generated GoMock package.
package mock_vendor_dep

import (
        reflect "reflect"

        gomock "github.com/golang/mock/gomock"
        present "golang.org/x/tools/present"
)

// MockVendorsDep is a mock of VendorsDep interface.
type MockVendorsDep struct {
        ctrl     *gomock.Controller
        recorder *MockVendorsDepMockRecorder
}

// MockVendorsDepMockRecorder is the mock recorder for MockVendorsDep.
type MockVendorsDepMockRecorder struct {
        mock *MockVendorsDep
}

// NewMockVendorsDep creates a new mock instance.
func NewMockVendorsDep(ctrl *gomock.Controller) *MockVendorsDep <span class="cov0" title="0">{
        mock := &amp;MockVendorsDep{ctrl: ctrl}
        mock.recorder = &amp;MockVendorsDepMockRecorder{mock}
        return mock
}</span>

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockVendorsDep) EXPECT() *MockVendorsDepMockRecorder <span class="cov0" title="0">{
        return m.recorder
}</span>

// Foo mocks base method.
func (m *MockVendorsDep) Foo() present.Elem <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Foo")
        ret0, _ := ret[0].(present.Elem)
        return ret0
}</span>

// Foo indicates an expected call of Foo.
func (mr *MockVendorsDepMockRecorder) Foo() *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Foo", reflect.TypeOf((*MockVendorsDep)(nil).Foo))
}</span>
</pre>
		
		<pre class="file" id="file37" style="display: none">// Code generated by MockGen. DO NOT EDIT.
// Source: golang.org/x/tools/present (interfaces: Elem)

// Package vendor_pkg is a generated GoMock package.
package vendor_pkg

import (
        reflect "reflect"

        gomock "github.com/golang/mock/gomock"
)

// MockElem is a mock of Elem interface.
type MockElem struct {
        ctrl     *gomock.Controller
        recorder *MockElemMockRecorder
}

// MockElemMockRecorder is the mock recorder for MockElem.
type MockElemMockRecorder struct {
        mock *MockElem
}

// NewMockElem creates a new mock instance.
func NewMockElem(ctrl *gomock.Controller) *MockElem <span class="cov0" title="0">{
        mock := &amp;MockElem{ctrl: ctrl}
        mock.recorder = &amp;MockElemMockRecorder{mock}
        return mock
}</span>

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockElem) EXPECT() *MockElemMockRecorder <span class="cov0" title="0">{
        return m.recorder
}</span>

// TemplateName mocks base method.
func (m *MockElem) TemplateName() string <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "TemplateName")
        ret0, _ := ret[0].(string)
        return ret0
}</span>

// TemplateName indicates an expected call of TemplateName.
func (mr *MockElemMockRecorder) TemplateName() *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "TemplateName", reflect.TypeOf((*MockElem)(nil).TemplateName))
}</span>
</pre>
		
		<pre class="file" id="file38" style="display: none">// Copyright 2010 Google Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// MockGen generates mock implementations of Go interfaces.
package main

// TODO: This does not support recursive embedded interfaces.
// TODO: This does not support embedding package-local interfaces in a separate file.

import (
        "bytes"
        "encoding/json"
        "errors"
        "flag"
        "fmt"
        "go/token"
        "io"
        "io/ioutil"
        "log"
        "os"
        "os/exec"
        "path"
        "path/filepath"
        "sort"
        "strconv"
        "strings"
        "unicode"

        "github.com/golang/mock/mockgen/model"

        "golang.org/x/mod/modfile"
        toolsimports "golang.org/x/tools/imports"
)

const (
        gomockImportPath = "github.com/golang/mock/gomock"
)

var (
        version = ""
        commit  = "none"
        date    = "unknown"
)

var (
        source          = flag.String("source", "", "(source mode) Input Go source file; enables source mode.")
        destination     = flag.String("destination", "", "Output file; defaults to stdout.")
        mockNames       = flag.String("mock_names", "", "Comma-separated interfaceName=mockName pairs of explicit mock names to use. Mock names default to 'Mock'+ interfaceName suffix.")
        packageOut      = flag.String("package", "", "Package of the generated code; defaults to the package of the input with a 'mock_' prefix.")
        selfPackage     = flag.String("self_package", "", "The full package import path for the generated code. The purpose of this flag is to prevent import cycles in the generated code by trying to include its own package. This can happen if the mock's package is set to one of its inputs (usually the main one) and the output is stdio so mockgen cannot detect the final output package. Setting this flag will then tell mockgen which import to exclude.")
        writePkgComment = flag.Bool("write_package_comment", true, "Writes package documentation comment (godoc) if true.")
        copyrightFile   = flag.String("copyright_file", "", "Copyright file used to add copyright header")

        debugParser = flag.Bool("debug_parser", false, "Print out parser results only.")
        showVersion = flag.Bool("version", false, "Print version.")
)

func main() <span class="cov0" title="0">{
        flag.Usage = usage
        flag.Parse()

        if *showVersion </span><span class="cov0" title="0">{
                printVersion()
                return
        }</span>

        <span class="cov0" title="0">var pkg *model.Package
        var err error
        var packageName string
        if *source != "" </span><span class="cov0" title="0">{
                pkg, err = sourceMode(*source)
        }</span> else<span class="cov0" title="0"> {
                if flag.NArg() != 2 </span><span class="cov0" title="0">{
                        usage()
                        log.Fatal("Expected exactly two arguments")
                }</span>
                <span class="cov0" title="0">packageName = flag.Arg(0)
                interfaces := strings.Split(flag.Arg(1), ",")
                if packageName == "." </span><span class="cov0" title="0">{
                        dir, err := os.Getwd()
                        if err != nil </span><span class="cov0" title="0">{
                                log.Fatalf("Get current directory failed: %v", err)
                        }</span>
                        <span class="cov0" title="0">packageName, err = packageNameOfDir(dir)
                        if err != nil </span><span class="cov0" title="0">{
                                log.Fatalf("Parse package name failed: %v", err)
                        }</span>
                }
                <span class="cov0" title="0">pkg, err = reflectMode(packageName, interfaces)</span>
        }
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Loading input failed: %v", err)
        }</span>

        <span class="cov0" title="0">if *debugParser </span><span class="cov0" title="0">{
                pkg.Print(os.Stdout)
                return
        }</span>

        <span class="cov0" title="0">outputPackageName := *packageOut
        if outputPackageName == "" </span><span class="cov0" title="0">{
                // pkg.Name in reflect mode is the base name of the import path,
                // which might have characters that are illegal to have in package names.
                outputPackageName = "mock_" + sanitize(pkg.Name)
        }</span>

        // outputPackagePath represents the fully qualified name of the package of
        // the generated code. Its purposes are to prevent the module from importing
        // itself and to prevent qualifying type names that come from its own
        // package (i.e. if there is a type called X then we want to print "X" not
        // "package.X" since "package" is this package). This can happen if the mock
        // is output into an already existing package.
        <span class="cov0" title="0">outputPackagePath := *selfPackage
        if outputPackagePath == "" &amp;&amp; *destination != "" </span><span class="cov0" title="0">{
                dstPath, err := filepath.Abs(filepath.Dir(*destination))
                if err == nil </span><span class="cov0" title="0">{
                        pkgPath, err := parsePackageImport(dstPath)
                        if err == nil </span><span class="cov0" title="0">{
                                outputPackagePath = pkgPath
                        }</span> else<span class="cov0" title="0"> {
                                log.Println("Unable to infer -self_package from destination file path:", err)
                        }</span>
                } else<span class="cov0" title="0"> {
                        log.Println("Unable to determine destination file path:", err)
                }</span>
        }

        <span class="cov0" title="0">g := new(generator)
        if *source != "" </span><span class="cov0" title="0">{
                g.filename = *source
        }</span> else<span class="cov0" title="0"> {
                g.srcPackage = packageName
                g.srcInterfaces = flag.Arg(1)
        }</span>
        <span class="cov0" title="0">g.destination = *destination

        if *mockNames != "" </span><span class="cov0" title="0">{
                g.mockNames = parseMockNames(*mockNames)
        }</span>
        <span class="cov0" title="0">if *copyrightFile != "" </span><span class="cov0" title="0">{
                header, err := ioutil.ReadFile(*copyrightFile)
                if err != nil </span><span class="cov0" title="0">{
                        log.Fatalf("Failed reading copyright file: %v", err)
                }</span>

                <span class="cov0" title="0">g.copyrightHeader = string(header)</span>
        }
        <span class="cov0" title="0">if err := g.Generate(pkg, outputPackageName, outputPackagePath); err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Failed generating mock: %v", err)
        }</span>
        <span class="cov0" title="0">output := g.Output()
        dst := os.Stdout
        if len(*destination) &gt; 0 </span><span class="cov0" title="0">{
                if err := os.MkdirAll(filepath.Dir(*destination), os.ModePerm); err != nil </span><span class="cov0" title="0">{
                        log.Fatalf("Unable to create directory: %v", err)
                }</span>
                <span class="cov0" title="0">existing, err := ioutil.ReadFile(*destination)
                if err != nil &amp;&amp; !errors.Is(err, os.ErrNotExist) </span><span class="cov0" title="0">{
                        log.Fatalf("Failed reading pre-exiting destination file: %v", err)
                }</span>
                <span class="cov0" title="0">if len(existing) == len(output) &amp;&amp; bytes.Compare(existing, output) == 0 </span><span class="cov0" title="0">{
                        return
                }</span>
                <span class="cov0" title="0">f, err := os.Create(*destination)
                if err != nil </span><span class="cov0" title="0">{
                        log.Fatalf("Failed opening destination file: %v", err)
                }</span>
                <span class="cov0" title="0">defer f.Close()
                dst = f</span>
        }
        <span class="cov0" title="0">if _, err := dst.Write(output); err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Failed writing to destination: %v", err)
        }</span>
}

func parseMockNames(names string) map[string]string <span class="cov0" title="0">{
        mocksMap := make(map[string]string)
        for _, kv := range strings.Split(names, ",") </span><span class="cov0" title="0">{
                parts := strings.SplitN(kv, "=", 2)
                if len(parts) != 2 || parts[1] == "" </span><span class="cov0" title="0">{
                        log.Fatalf("bad mock names spec: %v", kv)
                }</span>
                <span class="cov0" title="0">mocksMap[parts[0]] = parts[1]</span>
        }
        <span class="cov0" title="0">return mocksMap</span>
}

func usage() <span class="cov0" title="0">{
        _, _ = io.WriteString(os.Stderr, usageText)
        flag.PrintDefaults()
}</span>

const usageText = `mockgen has two modes of operation: source and reflect.

Source mode generates mock interfaces from a source file.
It is enabled by using the -source flag. Other flags that
may be useful in this mode are -imports and -aux_files.
Example:
        mockgen -source=foo.go [other options]

Reflect mode generates mock interfaces by building a program
that uses reflection to understand interfaces. It is enabled
by passing two non-flag arguments: an import path, and a
comma-separated list of symbols.
Example:
        mockgen database/sql/driver Conn,Driver

`

type generator struct {
        buf                       bytes.Buffer
        indent                    string
        mockNames                 map[string]string // may be empty
        filename                  string            // may be empty
        destination               string            // may be empty
        srcPackage, srcInterfaces string            // may be empty
        copyrightHeader           string

        packageMap map[string]string // map from import path to package name
}

func (g *generator) p(format string, args ...interface{}) <span class="cov8" title="1">{
        fmt.Fprintf(&amp;g.buf, g.indent+format+"\n", args...)
}</span>

func (g *generator) in() <span class="cov8" title="1">{
        g.indent += "\t"
}</span>

func (g *generator) out() <span class="cov8" title="1">{
        if len(g.indent) &gt; 0 </span><span class="cov8" title="1">{
                g.indent = g.indent[0 : len(g.indent)-1]
        }</span>
}

// sanitize cleans up a string to make a suitable package name.
func sanitize(s string) string <span class="cov0" title="0">{
        t := ""
        for _, r := range s </span><span class="cov0" title="0">{
                if t == "" </span><span class="cov0" title="0">{
                        if unicode.IsLetter(r) || r == '_' </span><span class="cov0" title="0">{
                                t += string(r)
                                continue</span>
                        }
                } else<span class="cov0" title="0"> {
                        if unicode.IsLetter(r) || unicode.IsDigit(r) || r == '_' </span><span class="cov0" title="0">{
                                t += string(r)
                                continue</span>
                        }
                }
                <span class="cov0" title="0">t += "_"</span>
        }
        <span class="cov0" title="0">if t == "_" </span><span class="cov0" title="0">{
                t = "x"
        }</span>
        <span class="cov0" title="0">return t</span>
}

func (g *generator) Generate(pkg *model.Package, outputPkgName string, outputPackagePath string) error <span class="cov0" title="0">{
        if outputPkgName != pkg.Name &amp;&amp; *selfPackage == "" </span><span class="cov0" title="0">{
                // reset outputPackagePath if it's not passed in through -self_package
                outputPackagePath = ""
        }</span>

        <span class="cov0" title="0">if g.copyrightHeader != "" </span><span class="cov0" title="0">{
                lines := strings.Split(g.copyrightHeader, "\n")
                for _, line := range lines </span><span class="cov0" title="0">{
                        g.p("// %s", line)
                }</span>
                <span class="cov0" title="0">g.p("")</span>
        }

        <span class="cov0" title="0">g.p("// Code generated by MockGen. DO NOT EDIT.")
        if g.filename != "" </span><span class="cov0" title="0">{
                g.p("// Source: %v", g.filename)
        }</span> else<span class="cov0" title="0"> {
                g.p("// Source: %v (interfaces: %v)", g.srcPackage, g.srcInterfaces)
        }</span>
        <span class="cov0" title="0">g.p("")

        // Get all required imports, and generate unique names for them all.
        im := pkg.Imports()
        im[gomockImportPath] = true

        // Only import reflect if it's used. We only use reflect in mocked methods
        // so only import if any of the mocked interfaces have methods.
        for _, intf := range pkg.Interfaces </span><span class="cov0" title="0">{
                if len(intf.Methods) &gt; 0 </span><span class="cov0" title="0">{
                        im["reflect"] = true
                        break</span>
                }
        }

        // Sort keys to make import alias generation predictable
        <span class="cov0" title="0">sortedPaths := make([]string, len(im))
        x := 0
        for pth := range im </span><span class="cov0" title="0">{
                sortedPaths[x] = pth
                x++
        }</span>
        <span class="cov0" title="0">sort.Strings(sortedPaths)

        packagesName := createPackageMap(sortedPaths)

        g.packageMap = make(map[string]string, len(im))
        localNames := make(map[string]bool, len(im))
        for _, pth := range sortedPaths </span><span class="cov0" title="0">{
                base, ok := packagesName[pth]
                if !ok </span><span class="cov0" title="0">{
                        base = sanitize(path.Base(pth))
                }</span>

                // Local names for an imported package can usually be the basename of the import path.
                // A couple of situations don't permit that, such as duplicate local names
                // (e.g. importing "html/template" and "text/template"), or where the basename is
                // a keyword (e.g. "foo/case").
                // try base0, base1, ...
                <span class="cov0" title="0">pkgName := base
                i := 0
                for localNames[pkgName] || token.Lookup(pkgName).IsKeyword() </span><span class="cov0" title="0">{
                        pkgName = base + strconv.Itoa(i)
                        i++
                }</span>

                // Avoid importing package if source pkg == output pkg
                <span class="cov0" title="0">if pth == pkg.PkgPath &amp;&amp; outputPackagePath == pkg.PkgPath </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">g.packageMap[pth] = pkgName
                localNames[pkgName] = true</span>
        }

        <span class="cov0" title="0">if *writePkgComment </span><span class="cov0" title="0">{
                g.p("// Package %v is a generated GoMock package.", outputPkgName)
        }</span>
        <span class="cov0" title="0">g.p("package %v", outputPkgName)
        g.p("")
        g.p("import (")
        g.in()
        for pkgPath, pkgName := range g.packageMap </span><span class="cov0" title="0">{
                if pkgPath == outputPackagePath </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">g.p("%v %q", pkgName, pkgPath)</span>
        }
        <span class="cov0" title="0">for _, pkgPath := range pkg.DotImports </span><span class="cov0" title="0">{
                g.p(". %q", pkgPath)
        }</span>
        <span class="cov0" title="0">g.out()
        g.p(")")

        for _, intf := range pkg.Interfaces </span><span class="cov0" title="0">{
                if err := g.GenerateMockInterface(intf, outputPackagePath); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// The name of the mock type to use for the given interface identifier.
func (g *generator) mockName(typeName string) string <span class="cov8" title="1">{
        if mockName, ok := g.mockNames[typeName]; ok </span><span class="cov0" title="0">{
                return mockName
        }</span>

        <span class="cov8" title="1">return "Mock" + typeName</span>
}

// formattedTypeParams returns a long and short form of type param info used for
// printing. If analyzing a interface with type param [I any, O any] the result
// will be:
// "[I any, O any]", "[I, O]"
func (g *generator) formattedTypeParams(it *model.Interface, pkgOverride string) (string, string) <span class="cov8" title="1">{
        if len(it.TypeParams) == 0 </span><span class="cov8" title="1">{
                return "", ""
        }</span>
        <span class="cov0" title="0">var long, short strings.Builder
        long.WriteString("[")
        short.WriteString("[")
        for i, v := range it.TypeParams </span><span class="cov0" title="0">{
                if i != 0 </span><span class="cov0" title="0">{
                        long.WriteString(", ")
                        short.WriteString(", ")
                }</span>
                <span class="cov0" title="0">long.WriteString(v.Name)
                short.WriteString(v.Name)
                long.WriteString(fmt.Sprintf(" %s", v.Type.String(g.packageMap, pkgOverride)))</span>
        }
        <span class="cov0" title="0">long.WriteString("]")
        short.WriteString("]")
        return long.String(), short.String()</span>
}

func (g *generator) GenerateMockInterface(intf *model.Interface, outputPackagePath string) error <span class="cov8" title="1">{
        mockType := g.mockName(intf.Name)
        longTp, shortTp := g.formattedTypeParams(intf, outputPackagePath)

        g.p("")
        g.p("// %v is a mock of %v interface.", mockType, intf.Name)
        g.p("type %v%v struct {", mockType, longTp)
        g.in()
        g.p("ctrl     *gomock.Controller")
        g.p("recorder *%vMockRecorder%v", mockType, shortTp)
        g.out()
        g.p("}")
        g.p("")

        g.p("// %vMockRecorder is the mock recorder for %v.", mockType, mockType)
        g.p("type %vMockRecorder%v struct {", mockType, longTp)
        g.in()
        g.p("mock *%v%v", mockType, shortTp)
        g.out()
        g.p("}")
        g.p("")

        g.p("// New%v creates a new mock instance.", mockType)
        g.p("func New%v%v(ctrl *gomock.Controller) *%v%v {", mockType, longTp, mockType, shortTp)
        g.in()
        g.p("mock := &amp;%v%v{ctrl: ctrl}", mockType, shortTp)
        g.p("mock.recorder = &amp;%vMockRecorder%v{mock}", mockType, shortTp)
        g.p("return mock")
        g.out()
        g.p("}")
        g.p("")

        // XXX: possible name collision here if someone has EXPECT in their interface.
        g.p("// EXPECT returns an object that allows the caller to indicate expected use.")
        g.p("func (m *%v%v) EXPECT() *%vMockRecorder%v {", mockType, shortTp, mockType, shortTp)
        g.in()
        g.p("return m.recorder")
        g.out()
        g.p("}")

        g.GenerateMockMethods(mockType, intf, outputPackagePath, shortTp)

        return nil
}</span>

type byMethodName []*model.Method

func (b byMethodName) Len() int           <span class="cov8" title="1">{ return len(b) }</span>
func (b byMethodName) Swap(i, j int)      <span class="cov0" title="0">{ b[i], b[j] = b[j], b[i] }</span>
func (b byMethodName) Less(i, j int) bool <span class="cov8" title="1">{ return b[i].Name &lt; b[j].Name }</span>

func (g *generator) GenerateMockMethods(mockType string, intf *model.Interface, pkgOverride, shortTp string) <span class="cov8" title="1">{
        sort.Sort(byMethodName(intf.Methods))
        for _, m := range intf.Methods </span><span class="cov8" title="1">{
                g.p("")
                _ = g.GenerateMockMethod(mockType, m, pkgOverride, shortTp)
                g.p("")
                _ = g.GenerateMockRecorderMethod(mockType, m, shortTp)
        }</span>
}

func makeArgString(argNames, argTypes []string) string <span class="cov8" title="1">{
        args := make([]string, len(argNames))
        for i, name := range argNames </span><span class="cov8" title="1">{
                // specify the type only once for consecutive args of the same type
                if i+1 &lt; len(argTypes) &amp;&amp; argTypes[i] == argTypes[i+1] </span><span class="cov8" title="1">{
                        args[i] = name
                }</span> else<span class="cov8" title="1"> {
                        args[i] = name + " " + argTypes[i]
                }</span>
        }
        <span class="cov8" title="1">return strings.Join(args, ", ")</span>
}

// GenerateMockMethod generates a mock method implementation.
// If non-empty, pkgOverride is the package in which unqualified types reside.
func (g *generator) GenerateMockMethod(mockType string, m *model.Method, pkgOverride, shortTp string) error <span class="cov8" title="1">{
        argNames := g.getArgNames(m)
        argTypes := g.getArgTypes(m, pkgOverride)
        argString := makeArgString(argNames, argTypes)

        rets := make([]string, len(m.Out))
        for i, p := range m.Out </span><span class="cov0" title="0">{
                rets[i] = p.Type.String(g.packageMap, pkgOverride)
        }</span>
        <span class="cov8" title="1">retString := strings.Join(rets, ", ")
        if len(rets) &gt; 1 </span><span class="cov0" title="0">{
                retString = "(" + retString + ")"
        }</span>
        <span class="cov8" title="1">if retString != "" </span><span class="cov0" title="0">{
                retString = " " + retString
        }</span>

        <span class="cov8" title="1">ia := newIdentifierAllocator(argNames)
        idRecv := ia.allocateIdentifier("m")

        g.p("// %v mocks base method.", m.Name)
        g.p("func (%v *%v%v) %v(%v)%v {", idRecv, mockType, shortTp, m.Name, argString, retString)
        g.in()
        g.p("%s.ctrl.T.Helper()", idRecv)

        var callArgs string
        if m.Variadic == nil </span><span class="cov8" title="1">{
                if len(argNames) &gt; 0 </span><span class="cov8" title="1">{
                        callArgs = ", " + strings.Join(argNames, ", ")
                }</span>
        } else<span class="cov0" title="0"> {
                // Non-trivial. The generated code must build a []interface{},
                // but the variadic argument may be any type.
                idVarArgs := ia.allocateIdentifier("varargs")
                idVArg := ia.allocateIdentifier("a")
                g.p("%s := []interface{}{%s}", idVarArgs, strings.Join(argNames[:len(argNames)-1], ", "))
                g.p("for _, %s := range %s {", idVArg, argNames[len(argNames)-1])
                g.in()
                g.p("%s = append(%s, %s)", idVarArgs, idVarArgs, idVArg)
                g.out()
                g.p("}")
                callArgs = ", " + idVarArgs + "..."
        }</span>
        <span class="cov8" title="1">if len(m.Out) == 0 </span><span class="cov8" title="1">{
                g.p(`%v.ctrl.Call(%v, %q%v)`, idRecv, idRecv, m.Name, callArgs)
        }</span> else<span class="cov0" title="0"> {
                idRet := ia.allocateIdentifier("ret")
                g.p(`%v := %v.ctrl.Call(%v, %q%v)`, idRet, idRecv, idRecv, m.Name, callArgs)

                // Go does not allow "naked" type assertions on nil values, so we use the two-value form here.
                // The value of that is either (x.(T), true) or (Z, false), where Z is the zero value for T.
                // Happily, this coincides with the semantics we want here.
                retNames := make([]string, len(rets))
                for i, t := range rets </span><span class="cov0" title="0">{
                        retNames[i] = ia.allocateIdentifier(fmt.Sprintf("ret%d", i))
                        g.p("%s, _ := %s[%d].(%s)", retNames[i], idRet, i, t)
                }</span>
                <span class="cov0" title="0">g.p("return " + strings.Join(retNames, ", "))</span>
        }

        <span class="cov8" title="1">g.out()
        g.p("}")
        return nil</span>
}

func (g *generator) GenerateMockRecorderMethod(mockType string, m *model.Method, shortTp string) error <span class="cov8" title="1">{
        argNames := g.getArgNames(m)

        var argString string
        if m.Variadic == nil </span><span class="cov8" title="1">{
                argString = strings.Join(argNames, ", ")
        }</span> else<span class="cov0" title="0"> {
                argString = strings.Join(argNames[:len(argNames)-1], ", ")
        }</span>
        <span class="cov8" title="1">if argString != "" </span><span class="cov8" title="1">{
                argString += " interface{}"
        }</span>

        <span class="cov8" title="1">if m.Variadic != nil </span><span class="cov0" title="0">{
                if argString != "" </span><span class="cov0" title="0">{
                        argString += ", "
                }</span>
                <span class="cov0" title="0">argString += fmt.Sprintf("%s ...interface{}", argNames[len(argNames)-1])</span>
        }

        <span class="cov8" title="1">ia := newIdentifierAllocator(argNames)
        idRecv := ia.allocateIdentifier("mr")

        g.p("// %v indicates an expected call of %v.", m.Name, m.Name)
        g.p("func (%s *%vMockRecorder%v) %v(%v) *gomock.Call {", idRecv, mockType, shortTp, m.Name, argString)
        g.in()
        g.p("%s.mock.ctrl.T.Helper()", idRecv)

        var callArgs string
        if m.Variadic == nil </span><span class="cov8" title="1">{
                if len(argNames) &gt; 0 </span><span class="cov8" title="1">{
                        callArgs = ", " + strings.Join(argNames, ", ")
                }</span>
        } else<span class="cov0" title="0"> {
                if len(argNames) == 1 </span><span class="cov0" title="0">{
                        // Easy: just use ... to push the arguments through.
                        callArgs = ", " + argNames[0] + "..."
                }</span> else<span class="cov0" title="0"> {
                        // Hard: create a temporary slice.
                        idVarArgs := ia.allocateIdentifier("varargs")
                        g.p("%s := append([]interface{}{%s}, %s...)",
                                idVarArgs,
                                strings.Join(argNames[:len(argNames)-1], ", "),
                                argNames[len(argNames)-1])
                        callArgs = ", " + idVarArgs + "..."
                }</span>
        }
        <span class="cov8" title="1">g.p(`return %s.mock.ctrl.RecordCallWithMethodType(%s.mock, "%s", reflect.TypeOf((*%s%s)(nil).%s)%s)`, idRecv, idRecv, m.Name, mockType, shortTp, m.Name, callArgs)

        g.out()
        g.p("}")
        return nil</span>
}

func (g *generator) getArgNames(m *model.Method) []string <span class="cov8" title="1">{
        argNames := make([]string, len(m.In))
        for i, p := range m.In </span><span class="cov8" title="1">{
                name := p.Name
                if name == "" || name == "_" </span><span class="cov8" title="1">{
                        name = fmt.Sprintf("arg%d", i)
                }</span>
                <span class="cov8" title="1">argNames[i] = name</span>
        }
        <span class="cov8" title="1">if m.Variadic != nil </span><span class="cov0" title="0">{
                name := m.Variadic.Name
                if name == "" </span><span class="cov0" title="0">{
                        name = fmt.Sprintf("arg%d", len(m.In))
                }</span>
                <span class="cov0" title="0">argNames = append(argNames, name)</span>
        }
        <span class="cov8" title="1">return argNames</span>
}

func (g *generator) getArgTypes(m *model.Method, pkgOverride string) []string <span class="cov8" title="1">{
        argTypes := make([]string, len(m.In))
        for i, p := range m.In </span><span class="cov8" title="1">{
                argTypes[i] = p.Type.String(g.packageMap, pkgOverride)
        }</span>
        <span class="cov8" title="1">if m.Variadic != nil </span><span class="cov0" title="0">{
                argTypes = append(argTypes, "..."+m.Variadic.Type.String(g.packageMap, pkgOverride))
        }</span>
        <span class="cov8" title="1">return argTypes</span>
}

type identifierAllocator map[string]struct{}

func newIdentifierAllocator(taken []string) identifierAllocator <span class="cov8" title="1">{
        a := make(identifierAllocator, len(taken))
        for _, s := range taken </span><span class="cov8" title="1">{
                a[s] = struct{}{}
        }</span>
        <span class="cov8" title="1">return a</span>
}

func (o identifierAllocator) allocateIdentifier(want string) string <span class="cov8" title="1">{
        id := want
        for i := 2; ; i++ </span><span class="cov8" title="1">{
                if _, ok := o[id]; !ok </span><span class="cov8" title="1">{
                        o[id] = struct{}{}
                        return id
                }</span>
                <span class="cov8" title="1">id = want + "_" + strconv.Itoa(i)</span>
        }
}

// Output returns the generator's output, formatted in the standard Go style.
func (g *generator) Output() []byte <span class="cov0" title="0">{
        src, err := toolsimports.Process(g.destination, g.buf.Bytes(), nil)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Failed to format generated source code: %s\n%s", err, g.buf.String())
        }</span>
        <span class="cov0" title="0">return src</span>
}

// createPackageMap returns a map of import path to package name
// for specified importPaths.
func createPackageMap(importPaths []string) map[string]string <span class="cov8" title="1">{
        var pkg struct {
                Name       string
                ImportPath string
        }
        pkgMap := make(map[string]string)
        b := bytes.NewBuffer(nil)
        args := []string{"list", "-json"}
        args = append(args, importPaths...)
        cmd := exec.Command("go", args...)
        cmd.Stdout = b
        cmd.Run()
        dec := json.NewDecoder(b)
        for dec.More() </span><span class="cov8" title="1">{
                err := dec.Decode(&amp;pkg)
                if err != nil </span><span class="cov0" title="0">{
                        log.Printf("failed to decode 'go list' output: %v", err)
                        continue</span>
                }
                <span class="cov8" title="1">pkgMap[pkg.ImportPath] = pkg.Name</span>
        }
        <span class="cov8" title="1">return pkgMap</span>
}

func printVersion() <span class="cov0" title="0">{
        if version != "" </span><span class="cov0" title="0">{
                fmt.Printf("v%s\nCommit: %s\nDate: %s\n", version, commit, date)
        }</span> else<span class="cov0" title="0"> {
                printModuleVersion()
        }</span>
}

// parseImportPackage get package import path via source file
// an alternative implementation is to use:
// cfg := &amp;packages.Config{Mode: packages.NeedName, Tests: true, Dir: srcDir}
// pkgs, err := packages.Load(cfg, "file="+source)
// However, it will call "go list" and slow down the performance
func parsePackageImport(srcDir string) (string, error) <span class="cov8" title="1">{
        moduleMode := os.Getenv("GO111MODULE")
        // trying to find the module
        if moduleMode != "off" </span><span class="cov8" title="1">{
                currentDir := srcDir
                for </span><span class="cov8" title="1">{
                        dat, err := ioutil.ReadFile(filepath.Join(currentDir, "go.mod"))
                        if os.IsNotExist(err) </span><span class="cov8" title="1">{
                                if currentDir == filepath.Dir(currentDir) </span><span class="cov8" title="1">{
                                        // at the root
                                        break</span>
                                }
                                <span class="cov8" title="1">currentDir = filepath.Dir(currentDir)
                                continue</span>
                        } else<span class="cov0" title="0"> if err != nil </span><span class="cov0" title="0">{
                                return "", err
                        }</span>
                        <span class="cov0" title="0">modulePath := modfile.ModulePath(dat)
                        return filepath.ToSlash(filepath.Join(modulePath, strings.TrimPrefix(srcDir, currentDir))), nil</span>
                }
        }
        // fall back to GOPATH mode
        <span class="cov8" title="1">goPaths := os.Getenv("GOPATH")
        if goPaths == "" </span><span class="cov0" title="0">{
                return "", fmt.Errorf("GOPATH is not set")
        }</span>
        <span class="cov8" title="1">goPathList := strings.Split(goPaths, string(os.PathListSeparator))
        for _, goPath := range goPathList </span><span class="cov8" title="1">{
                sourceRoot := filepath.Join(goPath, "src") + string(os.PathSeparator)
                if strings.HasPrefix(srcDir, sourceRoot) </span><span class="cov8" title="1">{
                        return filepath.ToSlash(strings.TrimPrefix(srcDir, sourceRoot)), nil
                }</span>
        }
        <span class="cov0" title="0">return "", errOutsideGoPath</span>
}
</pre>
		
		<pre class="file" id="file39" style="display: none">// Copyright 2012 Google Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Package model contains the data model necessary for generating mock implementations.
package model

import (
        "encoding/gob"
        "fmt"
        "io"
        "reflect"
        "strings"
)

// pkgPath is the importable path for package model
const pkgPath = "github.com/golang/mock/mockgen/model"

// Package is a Go package. It may be a subset.
type Package struct {
        Name       string
        PkgPath    string
        Interfaces []*Interface
        DotImports []string
}

// Print writes the package name and its exported interfaces.
func (pkg *Package) Print(w io.Writer) <span class="cov0" title="0">{
        _, _ = fmt.Fprintf(w, "package %s\n", pkg.Name)
        for _, intf := range pkg.Interfaces </span><span class="cov0" title="0">{
                intf.Print(w)
        }</span>
}

// Imports returns the imports needed by the Package as a set of import paths.
func (pkg *Package) Imports() map[string]bool <span class="cov0" title="0">{
        im := make(map[string]bool)
        for _, intf := range pkg.Interfaces </span><span class="cov0" title="0">{
                intf.addImports(im)
                for _, tp := range intf.TypeParams </span><span class="cov0" title="0">{
                        tp.Type.addImports(im)
                }</span>
        }
        <span class="cov0" title="0">return im</span>
}

// Interface is a Go interface.
type Interface struct {
        Name       string
        Methods    []*Method
        TypeParams []*Parameter
}

// Print writes the interface name and its methods.
func (intf *Interface) Print(w io.Writer) <span class="cov0" title="0">{
        _, _ = fmt.Fprintf(w, "interface %s\n", intf.Name)
        for _, m := range intf.Methods </span><span class="cov0" title="0">{
                m.Print(w)
        }</span>
}

func (intf *Interface) addImports(im map[string]bool) <span class="cov0" title="0">{
        for _, m := range intf.Methods </span><span class="cov0" title="0">{
                m.addImports(im)
        }</span>
}

// AddMethod adds a new method, de-duplicating by method name.
func (intf *Interface) AddMethod(m *Method) <span class="cov0" title="0">{
        for _, me := range intf.Methods </span><span class="cov0" title="0">{
                if me.Name == m.Name </span><span class="cov0" title="0">{
                        return
                }</span>
        }
        <span class="cov0" title="0">intf.Methods = append(intf.Methods, m)</span>
}

// Method is a single method of an interface.
type Method struct {
        Name     string
        In, Out  []*Parameter
        Variadic *Parameter // may be nil
}

// Print writes the method name and its signature.
func (m *Method) Print(w io.Writer) <span class="cov0" title="0">{
        _, _ = fmt.Fprintf(w, "  - method %s\n", m.Name)
        if len(m.In) &gt; 0 </span><span class="cov0" title="0">{
                _, _ = fmt.Fprintf(w, "    in:\n")
                for _, p := range m.In </span><span class="cov0" title="0">{
                        p.Print(w)
                }</span>
        }
        <span class="cov0" title="0">if m.Variadic != nil </span><span class="cov0" title="0">{
                _, _ = fmt.Fprintf(w, "    ...:\n")
                m.Variadic.Print(w)
        }</span>
        <span class="cov0" title="0">if len(m.Out) &gt; 0 </span><span class="cov0" title="0">{
                _, _ = fmt.Fprintf(w, "    out:\n")
                for _, p := range m.Out </span><span class="cov0" title="0">{
                        p.Print(w)
                }</span>
        }
}

func (m *Method) addImports(im map[string]bool) <span class="cov0" title="0">{
        for _, p := range m.In </span><span class="cov0" title="0">{
                p.Type.addImports(im)
        }</span>
        <span class="cov0" title="0">if m.Variadic != nil </span><span class="cov0" title="0">{
                m.Variadic.Type.addImports(im)
        }</span>
        <span class="cov0" title="0">for _, p := range m.Out </span><span class="cov0" title="0">{
                p.Type.addImports(im)
        }</span>
}

// Parameter is an argument or return parameter of a method.
type Parameter struct {
        Name string // may be empty
        Type Type
}

// Print writes a method parameter.
func (p *Parameter) Print(w io.Writer) <span class="cov0" title="0">{
        n := p.Name
        if n == "" </span><span class="cov0" title="0">{
                n = `""`
        }</span>
        <span class="cov0" title="0">_, _ = fmt.Fprintf(w, "    - %v: %v\n", n, p.Type.String(nil, ""))</span>
}

// Type is a Go type.
type Type interface {
        String(pm map[string]string, pkgOverride string) string
        addImports(im map[string]bool)
}

func init() <span class="cov8" title="1">{
        gob.Register(&amp;ArrayType{})
        gob.Register(&amp;ChanType{})
        gob.Register(&amp;FuncType{})
        gob.Register(&amp;MapType{})
        gob.Register(&amp;NamedType{})
        gob.Register(&amp;PointerType{})

        // Call gob.RegisterName to make sure it has the consistent name registered
        // for both gob decoder and encoder.
        //
        // For a non-pointer type, gob.Register will try to get package full path by
        // calling rt.PkgPath() for a name to register. If your project has vendor
        // directory, it is possible that PkgPath will get a path like this:
        //     ../../../vendor/github.com/golang/mock/mockgen/model
        gob.RegisterName(pkgPath+".PredeclaredType", PredeclaredType(""))
}</span>

// ArrayType is an array or slice type.
type ArrayType struct {
        Len  int // -1 for slices, &gt;= 0 for arrays
        Type Type
}

func (at *ArrayType) String(pm map[string]string, pkgOverride string) string <span class="cov0" title="0">{
        s := "[]"
        if at.Len &gt; -1 </span><span class="cov0" title="0">{
                s = fmt.Sprintf("[%d]", at.Len)
        }</span>
        <span class="cov0" title="0">return s + at.Type.String(pm, pkgOverride)</span>
}

func (at *ArrayType) addImports(im map[string]bool) <span class="cov0" title="0">{ at.Type.addImports(im) }</span>

// ChanType is a channel type.
type ChanType struct {
        Dir  ChanDir // 0, 1 or 2
        Type Type
}

func (ct *ChanType) String(pm map[string]string, pkgOverride string) string <span class="cov0" title="0">{
        s := ct.Type.String(pm, pkgOverride)
        if ct.Dir == RecvDir </span><span class="cov0" title="0">{
                return "&lt;-chan " + s
        }</span>
        <span class="cov0" title="0">if ct.Dir == SendDir </span><span class="cov0" title="0">{
                return "chan&lt;- " + s
        }</span>
        <span class="cov0" title="0">return "chan " + s</span>
}

func (ct *ChanType) addImports(im map[string]bool) <span class="cov0" title="0">{ ct.Type.addImports(im) }</span>

// ChanDir is a channel direction.
type ChanDir int

// Constants for channel directions.
const (
        RecvDir ChanDir = 1
        SendDir ChanDir = 2
)

// FuncType is a function type.
type FuncType struct {
        In, Out  []*Parameter
        Variadic *Parameter // may be nil
}

func (ft *FuncType) String(pm map[string]string, pkgOverride string) string <span class="cov0" title="0">{
        args := make([]string, len(ft.In))
        for i, p := range ft.In </span><span class="cov0" title="0">{
                args[i] = p.Type.String(pm, pkgOverride)
        }</span>
        <span class="cov0" title="0">if ft.Variadic != nil </span><span class="cov0" title="0">{
                args = append(args, "..."+ft.Variadic.Type.String(pm, pkgOverride))
        }</span>
        <span class="cov0" title="0">rets := make([]string, len(ft.Out))
        for i, p := range ft.Out </span><span class="cov0" title="0">{
                rets[i] = p.Type.String(pm, pkgOverride)
        }</span>
        <span class="cov0" title="0">retString := strings.Join(rets, ", ")
        if nOut := len(ft.Out); nOut == 1 </span><span class="cov0" title="0">{
                retString = " " + retString
        }</span> else<span class="cov0" title="0"> if nOut &gt; 1 </span><span class="cov0" title="0">{
                retString = " (" + retString + ")"
        }</span>
        <span class="cov0" title="0">return "func(" + strings.Join(args, ", ") + ")" + retString</span>
}

func (ft *FuncType) addImports(im map[string]bool) <span class="cov0" title="0">{
        for _, p := range ft.In </span><span class="cov0" title="0">{
                p.Type.addImports(im)
        }</span>
        <span class="cov0" title="0">if ft.Variadic != nil </span><span class="cov0" title="0">{
                ft.Variadic.Type.addImports(im)
        }</span>
        <span class="cov0" title="0">for _, p := range ft.Out </span><span class="cov0" title="0">{
                p.Type.addImports(im)
        }</span>
}

// MapType is a map type.
type MapType struct {
        Key, Value Type
}

func (mt *MapType) String(pm map[string]string, pkgOverride string) string <span class="cov0" title="0">{
        return "map[" + mt.Key.String(pm, pkgOverride) + "]" + mt.Value.String(pm, pkgOverride)
}</span>

func (mt *MapType) addImports(im map[string]bool) <span class="cov0" title="0">{
        mt.Key.addImports(im)
        mt.Value.addImports(im)
}</span>

// NamedType is an exported type in a package.
type NamedType struct {
        Package    string // may be empty
        Type       string
        TypeParams *TypeParametersType
}

func (nt *NamedType) String(pm map[string]string, pkgOverride string) string <span class="cov0" title="0">{
        if pkgOverride == nt.Package </span><span class="cov0" title="0">{
                return nt.Type + nt.TypeParams.String(pm, pkgOverride)
        }</span>
        <span class="cov0" title="0">prefix := pm[nt.Package]
        if prefix != "" </span><span class="cov0" title="0">{
                return prefix + "." + nt.Type + nt.TypeParams.String(pm, pkgOverride)
        }</span>

        <span class="cov0" title="0">return nt.Type + nt.TypeParams.String(pm, pkgOverride)</span>
}

func (nt *NamedType) addImports(im map[string]bool) <span class="cov0" title="0">{
        if nt.Package != "" </span><span class="cov0" title="0">{
                im[nt.Package] = true
        }</span>
        <span class="cov0" title="0">nt.TypeParams.addImports(im)</span>
}

// PointerType is a pointer to another type.
type PointerType struct {
        Type Type
}

func (pt *PointerType) String(pm map[string]string, pkgOverride string) string <span class="cov0" title="0">{
        return "*" + pt.Type.String(pm, pkgOverride)
}</span>
func (pt *PointerType) addImports(im map[string]bool) <span class="cov0" title="0">{ pt.Type.addImports(im) }</span>

// PredeclaredType is a predeclared type such as "int".
type PredeclaredType string

func (pt PredeclaredType) String(map[string]string, string) string <span class="cov0" title="0">{ return string(pt) }</span>
func (pt PredeclaredType) addImports(map[string]bool)              {<span class="cov0" title="0">}</span>

// TypeParametersType contains type paramters for a NamedType.
type TypeParametersType struct {
        TypeParameters []Type
}

func (tp *TypeParametersType) String(pm map[string]string, pkgOverride string) string <span class="cov0" title="0">{
        if tp == nil || len(tp.TypeParameters) == 0 </span><span class="cov0" title="0">{
                return ""
        }</span>
        <span class="cov0" title="0">var sb strings.Builder
        sb.WriteString("[")
        for i, v := range tp.TypeParameters </span><span class="cov0" title="0">{
                if i != 0 </span><span class="cov0" title="0">{
                        sb.WriteString(", ")
                }</span>
                <span class="cov0" title="0">sb.WriteString(v.String(pm, pkgOverride))</span>
        }
        <span class="cov0" title="0">sb.WriteString("]")
        return sb.String()</span>
}

func (tp *TypeParametersType) addImports(im map[string]bool) <span class="cov0" title="0">{
        if tp == nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">for _, v := range tp.TypeParameters </span><span class="cov0" title="0">{
                v.addImports(im)
        }</span>
}

// The following code is intended to be called by the program generated by ../reflect.go.

// InterfaceFromInterfaceType returns a pointer to an interface for the
// given reflection interface type.
func InterfaceFromInterfaceType(it reflect.Type) (*Interface, error) <span class="cov0" title="0">{
        if it.Kind() != reflect.Interface </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("%v is not an interface", it)
        }</span>
        <span class="cov0" title="0">intf := &amp;Interface{}

        for i := 0; i &lt; it.NumMethod(); i++ </span><span class="cov0" title="0">{
                mt := it.Method(i)
                // TODO: need to skip unexported methods? or just raise an error?
                m := &amp;Method{
                        Name: mt.Name,
                }

                var err error
                m.In, m.Variadic, m.Out, err = funcArgsFromType(mt.Type)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                <span class="cov0" title="0">intf.AddMethod(m)</span>
        }

        <span class="cov0" title="0">return intf, nil</span>
}

// t's Kind must be a reflect.Func.
func funcArgsFromType(t reflect.Type) (in []*Parameter, variadic *Parameter, out []*Parameter, err error) <span class="cov0" title="0">{
        nin := t.NumIn()
        if t.IsVariadic() </span><span class="cov0" title="0">{
                nin--
        }</span>
        <span class="cov0" title="0">var p *Parameter
        for i := 0; i &lt; nin; i++ </span><span class="cov0" title="0">{
                p, err = parameterFromType(t.In(i))
                if err != nil </span><span class="cov0" title="0">{
                        return
                }</span>
                <span class="cov0" title="0">in = append(in, p)</span>
        }
        <span class="cov0" title="0">if t.IsVariadic() </span><span class="cov0" title="0">{
                p, err = parameterFromType(t.In(nin).Elem())
                if err != nil </span><span class="cov0" title="0">{
                        return
                }</span>
                <span class="cov0" title="0">variadic = p</span>
        }
        <span class="cov0" title="0">for i := 0; i &lt; t.NumOut(); i++ </span><span class="cov0" title="0">{
                p, err = parameterFromType(t.Out(i))
                if err != nil </span><span class="cov0" title="0">{
                        return
                }</span>
                <span class="cov0" title="0">out = append(out, p)</span>
        }
        <span class="cov0" title="0">return</span>
}

func parameterFromType(t reflect.Type) (*Parameter, error) <span class="cov0" title="0">{
        tt, err := typeFromType(t)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;Parameter{Type: tt}, nil</span>
}

var errorType = reflect.TypeOf((*error)(nil)).Elem()

var byteType = reflect.TypeOf(byte(0))

func typeFromType(t reflect.Type) (Type, error) <span class="cov0" title="0">{
        // Hack workaround for https://golang.org/issue/3853.
        // This explicit check should not be necessary.
        if t == byteType </span><span class="cov0" title="0">{
                return PredeclaredType("byte"), nil
        }</span>

        <span class="cov0" title="0">if imp := t.PkgPath(); imp != "" </span><span class="cov0" title="0">{
                return &amp;NamedType{
                        Package: impPath(imp),
                        Type:    t.Name(),
                }, nil
        }</span>

        // only unnamed or predeclared types after here

        // Lots of types have element types. Let's do the parsing and error checking for all of them.
        <span class="cov0" title="0">var elemType Type
        switch t.Kind() </span>{
        case reflect.Array, reflect.Chan, reflect.Map, reflect.Ptr, reflect.Slice:<span class="cov0" title="0">
                var err error
                elemType, err = typeFromType(t.Elem())
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
        }

        <span class="cov0" title="0">switch t.Kind() </span>{
        case reflect.Array:<span class="cov0" title="0">
                return &amp;ArrayType{
                        Len:  t.Len(),
                        Type: elemType,
                }, nil</span>
        case reflect.Bool, reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64,
                reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64, reflect.Uintptr,
                reflect.Float32, reflect.Float64, reflect.Complex64, reflect.Complex128, reflect.String:<span class="cov0" title="0">
                return PredeclaredType(t.Kind().String()), nil</span>
        case reflect.Chan:<span class="cov0" title="0">
                var dir ChanDir
                switch t.ChanDir() </span>{
                case reflect.RecvDir:<span class="cov0" title="0">
                        dir = RecvDir</span>
                case reflect.SendDir:<span class="cov0" title="0">
                        dir = SendDir</span>
                }
                <span class="cov0" title="0">return &amp;ChanType{
                        Dir:  dir,
                        Type: elemType,
                }, nil</span>
        case reflect.Func:<span class="cov0" title="0">
                in, variadic, out, err := funcArgsFromType(t)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return &amp;FuncType{
                        In:       in,
                        Out:      out,
                        Variadic: variadic,
                }, nil</span>
        case reflect.Interface:<span class="cov0" title="0">
                // Two special interfaces.
                if t.NumMethod() == 0 </span><span class="cov0" title="0">{
                        return PredeclaredType("interface{}"), nil
                }</span>
                <span class="cov0" title="0">if t == errorType </span><span class="cov0" title="0">{
                        return PredeclaredType("error"), nil
                }</span>
        case reflect.Map:<span class="cov0" title="0">
                kt, err := typeFromType(t.Key())
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return &amp;MapType{
                        Key:   kt,
                        Value: elemType,
                }, nil</span>
        case reflect.Ptr:<span class="cov0" title="0">
                return &amp;PointerType{
                        Type: elemType,
                }, nil</span>
        case reflect.Slice:<span class="cov0" title="0">
                return &amp;ArrayType{
                        Len:  -1,
                        Type: elemType,
                }, nil</span>
        case reflect.Struct:<span class="cov0" title="0">
                if t.NumField() == 0 </span><span class="cov0" title="0">{
                        return PredeclaredType("struct{}"), nil
                }</span>
        }

        // TODO: Struct, UnsafePointer
        <span class="cov0" title="0">return nil, fmt.Errorf("can't yet turn %v (%v) into a model.Type", t, t.Kind())</span>
}

// impPath sanitizes the package path returned by `PkgPath` method of a reflect Type so that
// it is importable. PkgPath might return a path that includes "vendor". These paths do not
// compile, so we need to remove everything up to and including "/vendor/".
// See https://github.com/golang/go/issues/12019.
func impPath(imp string) string <span class="cov8" title="1">{
        if strings.HasPrefix(imp, "vendor/") </span><span class="cov8" title="1">{
                imp = "/" + imp
        }</span>
        <span class="cov8" title="1">if i := strings.LastIndex(imp, "/vendor/"); i != -1 </span><span class="cov8" title="1">{
                imp = imp[i+len("/vendor/"):]
        }</span>
        <span class="cov8" title="1">return imp</span>
}

// ErrorInterface represent built-in error interface.
var ErrorInterface = Interface{
        Name: "error",
        Methods: []*Method{
                {
                        Name: "Error",
                        Out: []*Parameter{
                                {
                                        Name: "",
                                        Type: PredeclaredType("string"),
                                },
                        },
                },
        },
}
</pre>
		
		<pre class="file" id="file40" style="display: none">// Copyright 2012 Google Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package main

// This file contains the model construction by parsing source files.

import (
        "errors"
        "flag"
        "fmt"
        "go/ast"
        "go/build"
        "go/importer"
        "go/parser"
        "go/token"
        "go/types"
        "io/ioutil"
        "log"
        "path"
        "path/filepath"
        "strconv"
        "strings"

        "github.com/golang/mock/mockgen/model"
)

var (
        imports  = flag.String("imports", "", "(source mode) Comma-separated name=path pairs of explicit imports to use.")
        auxFiles = flag.String("aux_files", "", "(source mode) Comma-separated pkg=path pairs of auxiliary Go source files.")
)

// sourceMode generates mocks via source file.
func sourceMode(source string) (*model.Package, error) <span class="cov0" title="0">{
        srcDir, err := filepath.Abs(filepath.Dir(source))
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed getting source directory: %v", err)
        }</span>

        <span class="cov0" title="0">packageImport, err := parsePackageImport(srcDir)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">fs := token.NewFileSet()
        file, err := parser.ParseFile(fs, source, nil, 0)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed parsing source file %v: %v", source, err)
        }</span>

        <span class="cov0" title="0">p := &amp;fileParser{
                fileSet:            fs,
                imports:            make(map[string]importedPackage),
                importedInterfaces: newInterfaceCache(),
                auxInterfaces:      newInterfaceCache(),
                srcDir:             srcDir,
        }

        // Handle -imports.
        dotImports := make(map[string]bool)
        if *imports != "" </span><span class="cov0" title="0">{
                for _, kv := range strings.Split(*imports, ",") </span><span class="cov0" title="0">{
                        eq := strings.Index(kv, "=")
                        k, v := kv[:eq], kv[eq+1:]
                        if k == "." </span><span class="cov0" title="0">{
                                dotImports[v] = true
                        }</span> else<span class="cov0" title="0"> {
                                p.imports[k] = importedPkg{path: v}
                        }</span>
                }
        }

        // Handle -aux_files.
        <span class="cov0" title="0">if err := p.parseAuxFiles(*auxFiles); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">p.addAuxInterfacesFromFile(packageImport, file) // this file

        pkg, err := p.parseFile(packageImport, file)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">for pkgPath := range dotImports </span><span class="cov0" title="0">{
                pkg.DotImports = append(pkg.DotImports, pkgPath)
        }</span>
        <span class="cov0" title="0">return pkg, nil</span>
}

type importedPackage interface {
        Path() string
        Parser() *fileParser
}

type importedPkg struct {
        path   string
        parser *fileParser
}

func (i importedPkg) Path() string        <span class="cov8" title="1">{ return i.path }</span>
func (i importedPkg) Parser() *fileParser <span class="cov0" title="0">{ return i.parser }</span>

// duplicateImport is a bit of a misnomer. Currently the parser can't
// handle cases of multi-file packages importing different packages
// under the same name. Often these imports would not be problematic,
// so this type lets us defer raising an error unless the package name
// is actually used.
type duplicateImport struct {
        name       string
        duplicates []string
}

func (d duplicateImport) Error() string <span class="cov0" title="0">{
        return fmt.Sprintf("%q is ambiguous because of duplicate imports: %v", d.name, d.duplicates)
}</span>

func (d duplicateImport) Path() string        <span class="cov0" title="0">{ log.Fatal(d.Error()); return "" }</span>
func (d duplicateImport) Parser() *fileParser <span class="cov0" title="0">{ log.Fatal(d.Error()); return nil }</span>

type interfaceCache struct {
        m map[string]map[string]*namedInterface
}

func newInterfaceCache() *interfaceCache <span class="cov8" title="1">{
        return &amp;interfaceCache{
                m: make(map[string]map[string]*namedInterface),
        }
}</span>

func (i *interfaceCache) Set(pkg, name string, it *namedInterface) <span class="cov8" title="1">{
        if _, ok := i.m[pkg]; !ok </span><span class="cov8" title="1">{
                i.m[pkg] = make(map[string]*namedInterface)
        }</span>
        <span class="cov8" title="1">i.m[pkg][name] = it</span>
}

func (i *interfaceCache) Get(pkg, name string) *namedInterface <span class="cov0" title="0">{
        if _, ok := i.m[pkg]; !ok </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">return i.m[pkg][name]</span>
}

func (i *interfaceCache) GetASTIface(pkg, name string) *ast.InterfaceType <span class="cov0" title="0">{
        if _, ok := i.m[pkg]; !ok </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">it, ok := i.m[pkg][name]
        if !ok </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">return it.it</span>
}

type fileParser struct {
        fileSet            *token.FileSet
        imports            map[string]importedPackage // package name =&gt; imported package
        importedInterfaces *interfaceCache
        auxFiles           []*ast.File
        auxInterfaces      *interfaceCache
        srcDir             string
}

func (p *fileParser) errorf(pos token.Pos, format string, args ...interface{}) error <span class="cov0" title="0">{
        ps := p.fileSet.Position(pos)
        format = "%s:%d:%d: " + format
        args = append([]interface{}{ps.Filename, ps.Line, ps.Column}, args...)
        return fmt.Errorf(format, args...)
}</span>

func (p *fileParser) parseAuxFiles(auxFiles string) error <span class="cov0" title="0">{
        auxFiles = strings.TrimSpace(auxFiles)
        if auxFiles == "" </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">for _, kv := range strings.Split(auxFiles, ",") </span><span class="cov0" title="0">{
                parts := strings.SplitN(kv, "=", 2)
                if len(parts) != 2 </span><span class="cov0" title="0">{
                        return fmt.Errorf("bad aux file spec: %v", kv)
                }</span>
                <span class="cov0" title="0">pkg, fpath := parts[0], parts[1]

                file, err := parser.ParseFile(p.fileSet, fpath, nil, 0)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">p.auxFiles = append(p.auxFiles, file)
                p.addAuxInterfacesFromFile(pkg, file)</span>
        }
        <span class="cov0" title="0">return nil</span>
}

func (p *fileParser) addAuxInterfacesFromFile(pkg string, file *ast.File) <span class="cov0" title="0">{
        for ni := range iterInterfaces(file) </span><span class="cov0" title="0">{
                p.auxInterfaces.Set(pkg, ni.name.Name, ni)
        }</span>
}

// parseFile loads all file imports and auxiliary files import into the
// fileParser, parses all file interfaces and returns package model.
func (p *fileParser) parseFile(importPath string, file *ast.File) (*model.Package, error) <span class="cov8" title="1">{
        allImports, dotImports := importsOfFile(file)
        // Don't stomp imports provided by -imports. Those should take precedence.
        for pkg, pkgI := range allImports </span><span class="cov8" title="1">{
                if _, ok := p.imports[pkg]; !ok </span><span class="cov8" title="1">{
                        p.imports[pkg] = pkgI
                }</span>
        }
        // Add imports from auxiliary files, which might be needed for embedded interfaces.
        // Don't stomp any other imports.
        <span class="cov8" title="1">for _, f := range p.auxFiles </span><span class="cov0" title="0">{
                auxImports, _ := importsOfFile(f)
                for pkg, pkgI := range auxImports </span><span class="cov0" title="0">{
                        if _, ok := p.imports[pkg]; !ok </span><span class="cov0" title="0">{
                                p.imports[pkg] = pkgI
                        }</span>
                }
        }

        <span class="cov8" title="1">var is []*model.Interface
        for ni := range iterInterfaces(file) </span><span class="cov8" title="1">{
                i, err := p.parseInterface(ni.name.String(), importPath, ni)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">is = append(is, i)</span>
        }
        <span class="cov8" title="1">return &amp;model.Package{
                Name:       file.Name.String(),
                PkgPath:    importPath,
                Interfaces: is,
                DotImports: dotImports,
        }, nil</span>
}

// parsePackage loads package specified by path, parses it and returns
// a new fileParser with the parsed imports and interfaces.
func (p *fileParser) parsePackage(path string) (*fileParser, error) <span class="cov8" title="1">{
        newP := &amp;fileParser{
                fileSet:            token.NewFileSet(),
                imports:            make(map[string]importedPackage),
                importedInterfaces: newInterfaceCache(),
                auxInterfaces:      newInterfaceCache(),
                srcDir:             p.srcDir,
        }

        var pkgs map[string]*ast.Package
        if imp, err := build.Import(path, newP.srcDir, build.FindOnly); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span> else<span class="cov8" title="1"> if pkgs, err = parser.ParseDir(newP.fileSet, imp.Dir, nil, 0); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">for _, pkg := range pkgs </span><span class="cov8" title="1">{
                file := ast.MergePackageFiles(pkg, ast.FilterFuncDuplicates|ast.FilterUnassociatedComments|ast.FilterImportDuplicates)
                for ni := range iterInterfaces(file) </span><span class="cov8" title="1">{
                        newP.importedInterfaces.Set(path, ni.name.Name, ni)
                }</span>
                <span class="cov8" title="1">imports, _ := importsOfFile(file)
                for pkgName, pkgI := range imports </span><span class="cov8" title="1">{
                        newP.imports[pkgName] = pkgI
                }</span>
        }
        <span class="cov8" title="1">return newP, nil</span>
}

func (p *fileParser) parseInterface(name, pkg string, it *namedInterface) (*model.Interface, error) <span class="cov8" title="1">{
        iface := &amp;model.Interface{Name: name}
        tps := make(map[string]bool)

        tp, err := p.parseFieldList(pkg, it.typeParams, tps)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("unable to parse interface type parameters: %v", name)
        }</span>
        <span class="cov8" title="1">iface.TypeParams = tp
        for _, v := range tp </span><span class="cov0" title="0">{
                tps[v.Name] = true
        }</span>

        <span class="cov8" title="1">for _, field := range it.it.Methods.List </span><span class="cov8" title="1">{
                switch v := field.Type.(type) </span>{
                case *ast.FuncType:<span class="cov8" title="1">
                        if nn := len(field.Names); nn != 1 </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("expected one name for interface %v, got %d", iface.Name, nn)
                        }</span>
                        <span class="cov8" title="1">m := &amp;model.Method{
                                Name: field.Names[0].String(),
                        }
                        var err error
                        m.In, m.Variadic, m.Out, err = p.parseFunc(pkg, v, tps)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                        <span class="cov8" title="1">iface.AddMethod(m)</span>
                case *ast.Ident:<span class="cov0" title="0">
                        // Embedded interface in this package.
                        embeddedIfaceType := p.auxInterfaces.Get(pkg, v.String())
                        if embeddedIfaceType == nil </span><span class="cov0" title="0">{
                                embeddedIfaceType = p.importedInterfaces.Get(pkg, v.String())
                        }</span>

                        <span class="cov0" title="0">var embeddedIface *model.Interface
                        if embeddedIfaceType != nil </span><span class="cov0" title="0">{
                                var err error
                                embeddedIface, err = p.parseInterface(v.String(), pkg, embeddedIfaceType)
                                if err != nil </span><span class="cov0" title="0">{
                                        return nil, err
                                }</span>
                        } else<span class="cov0" title="0"> {
                                // This is built-in error interface.
                                if v.String() == model.ErrorInterface.Name </span><span class="cov0" title="0">{
                                        embeddedIface = &amp;model.ErrorInterface
                                }</span> else<span class="cov0" title="0"> {
                                        ip, err := p.parsePackage(pkg)
                                        if err != nil </span><span class="cov0" title="0">{
                                                return nil, p.errorf(v.Pos(), "could not parse package %s: %v", pkg, err)
                                        }</span>

                                        <span class="cov0" title="0">if embeddedIfaceType = ip.importedInterfaces.Get(pkg, v.String()); embeddedIfaceType == nil </span><span class="cov0" title="0">{
                                                return nil, p.errorf(v.Pos(), "unknown embedded interface %s.%s", pkg, v.String())
                                        }</span>

                                        <span class="cov0" title="0">embeddedIface, err = ip.parseInterface(v.String(), pkg, embeddedIfaceType)
                                        if err != nil </span><span class="cov0" title="0">{
                                                return nil, err
                                        }</span>
                                }
                        }
                        // Copy the methods.
                        <span class="cov0" title="0">for _, m := range embeddedIface.Methods </span><span class="cov0" title="0">{
                                iface.AddMethod(m)
                        }</span>
                case *ast.SelectorExpr:<span class="cov0" title="0">
                        // Embedded interface in another package.
                        filePkg, sel := v.X.(*ast.Ident).String(), v.Sel.String()
                        embeddedPkg, ok := p.imports[filePkg]
                        if !ok </span><span class="cov0" title="0">{
                                return nil, p.errorf(v.X.Pos(), "unknown package %s", filePkg)
                        }</span>

                        <span class="cov0" title="0">var embeddedIface *model.Interface
                        var err error
                        embeddedIfaceType := p.auxInterfaces.Get(filePkg, sel)
                        if embeddedIfaceType != nil </span><span class="cov0" title="0">{
                                embeddedIface, err = p.parseInterface(sel, filePkg, embeddedIfaceType)
                                if err != nil </span><span class="cov0" title="0">{
                                        return nil, err
                                }</span>
                        } else<span class="cov0" title="0"> {
                                path := embeddedPkg.Path()
                                parser := embeddedPkg.Parser()
                                if parser == nil </span><span class="cov0" title="0">{
                                        ip, err := p.parsePackage(path)
                                        if err != nil </span><span class="cov0" title="0">{
                                                return nil, p.errorf(v.Pos(), "could not parse package %s: %v", path, err)
                                        }</span>
                                        <span class="cov0" title="0">parser = ip
                                        p.imports[filePkg] = importedPkg{
                                                path:   embeddedPkg.Path(),
                                                parser: parser,
                                        }</span>
                                }
                                <span class="cov0" title="0">if embeddedIfaceType = parser.importedInterfaces.Get(path, sel); embeddedIfaceType == nil </span><span class="cov0" title="0">{
                                        return nil, p.errorf(v.Pos(), "unknown embedded interface %s.%s", path, sel)
                                }</span>
                                <span class="cov0" title="0">embeddedIface, err = parser.parseInterface(sel, path, embeddedIfaceType)
                                if err != nil </span><span class="cov0" title="0">{
                                        return nil, err
                                }</span>
                        }
                        // Copy the methods.
                        // TODO: apply shadowing rules.
                        <span class="cov0" title="0">for _, m := range embeddedIface.Methods </span><span class="cov0" title="0">{
                                iface.AddMethod(m)
                        }</span>
                default:<span class="cov0" title="0">
                        return nil, fmt.Errorf("don't know how to mock method of type %T", field.Type)</span>
                }
        }
        <span class="cov8" title="1">return iface, nil</span>
}

func (p *fileParser) parseFunc(pkg string, f *ast.FuncType, tps map[string]bool) (inParam []*model.Parameter, variadic *model.Parameter, outParam []*model.Parameter, err error) <span class="cov8" title="1">{
        if f.Params != nil </span><span class="cov8" title="1">{
                regParams := f.Params.List
                if isVariadic(f) </span><span class="cov0" title="0">{
                        n := len(regParams)
                        varParams := regParams[n-1:]
                        regParams = regParams[:n-1]
                        vp, err := p.parseFieldList(pkg, varParams, tps)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, nil, nil, p.errorf(varParams[0].Pos(), "failed parsing variadic argument: %v", err)
                        }</span>
                        <span class="cov0" title="0">variadic = vp[0]</span>
                }
                <span class="cov8" title="1">inParam, err = p.parseFieldList(pkg, regParams, tps)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, nil, nil, p.errorf(f.Pos(), "failed parsing arguments: %v", err)
                }</span>
        }
        <span class="cov8" title="1">if f.Results != nil </span><span class="cov8" title="1">{
                outParam, err = p.parseFieldList(pkg, f.Results.List, tps)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, nil, nil, p.errorf(f.Pos(), "failed parsing returns: %v", err)
                }</span>
        }
        <span class="cov8" title="1">return</span>
}

func (p *fileParser) parseFieldList(pkg string, fields []*ast.Field, tps map[string]bool) ([]*model.Parameter, error) <span class="cov8" title="1">{
        nf := 0
        for _, f := range fields </span><span class="cov8" title="1">{
                nn := len(f.Names)
                if nn == 0 </span><span class="cov8" title="1">{
                        nn = 1 // anonymous parameter
                }</span>
                <span class="cov8" title="1">nf += nn</span>
        }
        <span class="cov8" title="1">if nf == 0 </span><span class="cov8" title="1">{
                return nil, nil
        }</span>
        <span class="cov8" title="1">ps := make([]*model.Parameter, nf)
        i := 0 // destination index
        for _, f := range fields </span><span class="cov8" title="1">{
                t, err := p.parseType(pkg, f.Type, tps)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                <span class="cov8" title="1">if len(f.Names) == 0 </span><span class="cov8" title="1">{
                        // anonymous arg
                        ps[i] = &amp;model.Parameter{Type: t}
                        i++
                        continue</span>
                }
                <span class="cov0" title="0">for _, name := range f.Names </span><span class="cov0" title="0">{
                        ps[i] = &amp;model.Parameter{Name: name.Name, Type: t}
                        i++
                }</span>
        }
        <span class="cov8" title="1">return ps, nil</span>
}

func (p *fileParser) parseType(pkg string, typ ast.Expr, tps map[string]bool) (model.Type, error) <span class="cov8" title="1">{
        switch v := typ.(type) </span>{
        case *ast.ArrayType:<span class="cov8" title="1">
                ln := -1
                if v.Len != nil </span><span class="cov8" title="1">{
                        value, err := p.parseArrayLength(v.Len)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                        <span class="cov8" title="1">ln, err = strconv.Atoi(value)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, p.errorf(v.Len.Pos(), "bad array size: %v", err)
                        }</span>
                }
                <span class="cov8" title="1">t, err := p.parseType(pkg, v.Elt, tps)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">return &amp;model.ArrayType{Len: ln, Type: t}, nil</span>
        case *ast.ChanType:<span class="cov0" title="0">
                t, err := p.parseType(pkg, v.Value, tps)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">var dir model.ChanDir
                if v.Dir == ast.SEND </span><span class="cov0" title="0">{
                        dir = model.SendDir
                }</span>
                <span class="cov0" title="0">if v.Dir == ast.RECV </span><span class="cov0" title="0">{
                        dir = model.RecvDir
                }</span>
                <span class="cov0" title="0">return &amp;model.ChanType{Dir: dir, Type: t}, nil</span>
        case *ast.Ellipsis:<span class="cov0" title="0">
                // assume we're parsing a variadic argument
                return p.parseType(pkg, v.Elt, tps)</span>
        case *ast.FuncType:<span class="cov0" title="0">
                in, variadic, out, err := p.parseFunc(pkg, v, tps)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return &amp;model.FuncType{In: in, Out: out, Variadic: variadic}, nil</span>
        case *ast.Ident:<span class="cov8" title="1">
                if v.IsExported() &amp;&amp; !tps[v.Name] </span><span class="cov0" title="0">{
                        // `pkg` may be an aliased imported pkg
                        // if so, patch the import w/ the fully qualified import
                        maybeImportedPkg, ok := p.imports[pkg]
                        if ok </span><span class="cov0" title="0">{
                                pkg = maybeImportedPkg.Path()
                        }</span>
                        // assume type in this package
                        <span class="cov0" title="0">return &amp;model.NamedType{Package: pkg, Type: v.Name}, nil</span>
                }

                // assume predeclared type
                <span class="cov8" title="1">return model.PredeclaredType(v.Name), nil</span>
        case *ast.InterfaceType:<span class="cov0" title="0">
                if v.Methods != nil &amp;&amp; len(v.Methods.List) &gt; 0 </span><span class="cov0" title="0">{
                        return nil, p.errorf(v.Pos(), "can't handle non-empty unnamed interface types")
                }</span>
                <span class="cov0" title="0">return model.PredeclaredType("interface{}"), nil</span>
        case *ast.MapType:<span class="cov0" title="0">
                key, err := p.parseType(pkg, v.Key, tps)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">value, err := p.parseType(pkg, v.Value, tps)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return &amp;model.MapType{Key: key, Value: value}, nil</span>
        case *ast.SelectorExpr:<span class="cov8" title="1">
                pkgName := v.X.(*ast.Ident).String()
                pkg, ok := p.imports[pkgName]
                if !ok </span><span class="cov0" title="0">{
                        return nil, p.errorf(v.Pos(), "unknown package %q", pkgName)
                }</span>
                <span class="cov8" title="1">return &amp;model.NamedType{Package: pkg.Path(), Type: v.Sel.String()}, nil</span>
        case *ast.StarExpr:<span class="cov0" title="0">
                t, err := p.parseType(pkg, v.X, tps)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return &amp;model.PointerType{Type: t}, nil</span>
        case *ast.StructType:<span class="cov0" title="0">
                if v.Fields != nil &amp;&amp; len(v.Fields.List) &gt; 0 </span><span class="cov0" title="0">{
                        return nil, p.errorf(v.Pos(), "can't handle non-empty unnamed struct types")
                }</span>
                <span class="cov0" title="0">return model.PredeclaredType("struct{}"), nil</span>
        case *ast.ParenExpr:<span class="cov0" title="0">
                return p.parseType(pkg, v.X, tps)</span>
        default:<span class="cov0" title="0">
                mt, err := p.parseGenericType(pkg, typ, tps)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">if mt == nil </span><span class="cov0" title="0">{
                        break</span>
                }
                <span class="cov0" title="0">return mt, nil</span>
        }

        <span class="cov0" title="0">return nil, fmt.Errorf("don't know how to parse type %T", typ)</span>
}

func (p *fileParser) parseArrayLength(expr ast.Expr) (string, error) <span class="cov8" title="1">{
        switch val := expr.(type) </span>{
        case (*ast.BasicLit):<span class="cov8" title="1">
                return val.Value, nil</span>
        case (*ast.Ident):<span class="cov8" title="1">
                // when the length is a const defined locally
                return val.Obj.Decl.(*ast.ValueSpec).Values[0].(*ast.BasicLit).Value, nil</span>
        case (*ast.SelectorExpr):<span class="cov8" title="1">
                // when the length is a const defined in an external package
                usedPkg, err := importer.Default().Import(fmt.Sprintf("%s", val.X))
                if err != nil </span><span class="cov0" title="0">{
                        return "", p.errorf(expr.Pos(), "unknown package in array length: %v", err)
                }</span>
                <span class="cov8" title="1">ev, err := types.Eval(token.NewFileSet(), usedPkg, token.NoPos, val.Sel.Name)
                if err != nil </span><span class="cov0" title="0">{
                        return "", p.errorf(expr.Pos(), "unknown constant in array length: %v", err)
                }</span>
                <span class="cov8" title="1">return ev.Value.String(), nil</span>
        case (*ast.ParenExpr):<span class="cov8" title="1">
                return p.parseArrayLength(val.X)</span>
        case (*ast.BinaryExpr):<span class="cov8" title="1">
                x, err := p.parseArrayLength(val.X)
                if err != nil </span><span class="cov0" title="0">{
                        return "", err
                }</span>
                <span class="cov8" title="1">y, err := p.parseArrayLength(val.Y)
                if err != nil </span><span class="cov0" title="0">{
                        return "", err
                }</span>
                <span class="cov8" title="1">biExpr := fmt.Sprintf("%s%v%s", x, val.Op, y)
                tv, err := types.Eval(token.NewFileSet(), nil, token.NoPos, biExpr)
                if err != nil </span><span class="cov0" title="0">{
                        return "", p.errorf(expr.Pos(), "invalid expression in array length: %v", err)
                }</span>
                <span class="cov8" title="1">return tv.Value.String(), nil</span>
        default:<span class="cov0" title="0">
                return "", p.errorf(expr.Pos(), "invalid expression in array length: %v", val)</span>
        }
}

// importsOfFile returns a map of package name to import path
// of the imports in file.
func importsOfFile(file *ast.File) (normalImports map[string]importedPackage, dotImports []string) <span class="cov8" title="1">{
        var importPaths []string
        for _, is := range file.Imports </span><span class="cov8" title="1">{
                if is.Name != nil </span><span class="cov8" title="1">{
                        continue</span>
                }
                <span class="cov8" title="1">importPath := is.Path.Value[1 : len(is.Path.Value)-1] // remove quotes
                importPaths = append(importPaths, importPath)</span>
        }
        <span class="cov8" title="1">packagesName := createPackageMap(importPaths)
        normalImports = make(map[string]importedPackage)
        dotImports = make([]string, 0)
        for _, is := range file.Imports </span><span class="cov8" title="1">{
                var pkgName string
                importPath := is.Path.Value[1 : len(is.Path.Value)-1] // remove quotes

                if is.Name != nil </span><span class="cov8" title="1">{
                        // Named imports are always certain.
                        if is.Name.Name == "_" </span><span class="cov0" title="0">{
                                continue</span>
                        }
                        <span class="cov8" title="1">pkgName = is.Name.Name</span>
                } else<span class="cov8" title="1"> {
                        pkg, ok := packagesName[importPath]
                        if !ok </span><span class="cov0" title="0">{
                                // Fallback to import path suffix. Note that this is uncertain.
                                _, last := path.Split(importPath)
                                // If the last path component has dots, the first dot-delimited
                                // field is used as the name.
                                pkgName = strings.SplitN(last, ".", 2)[0]
                        }</span> else<span class="cov8" title="1"> {
                                pkgName = pkg
                        }</span>
                }

                <span class="cov8" title="1">if pkgName == "." </span><span class="cov0" title="0">{
                        dotImports = append(dotImports, importPath)
                }</span> else<span class="cov8" title="1"> {
                        if pkg, ok := normalImports[pkgName]; ok </span><span class="cov0" title="0">{
                                switch p := pkg.(type) </span>{
                                case duplicateImport:<span class="cov0" title="0">
                                        normalImports[pkgName] = duplicateImport{
                                                name:       p.name,
                                                duplicates: append([]string{importPath}, p.duplicates...),
                                        }</span>
                                case importedPkg:<span class="cov0" title="0">
                                        normalImports[pkgName] = duplicateImport{
                                                name:       pkgName,
                                                duplicates: []string{p.path, importPath},
                                        }</span>
                                }
                        } else<span class="cov8" title="1"> {
                                normalImports[pkgName] = importedPkg{path: importPath}
                        }</span>
                }
        }
        <span class="cov8" title="1">return</span>
}

type namedInterface struct {
        name       *ast.Ident
        it         *ast.InterfaceType
        typeParams []*ast.Field
}

// Create an iterator over all interfaces in file.
func iterInterfaces(file *ast.File) &lt;-chan *namedInterface <span class="cov8" title="1">{
        ch := make(chan *namedInterface)
        go func() </span><span class="cov8" title="1">{
                for _, decl := range file.Decls </span><span class="cov8" title="1">{
                        gd, ok := decl.(*ast.GenDecl)
                        if !ok || gd.Tok != token.TYPE </span><span class="cov8" title="1">{
                                continue</span>
                        }
                        <span class="cov8" title="1">for _, spec := range gd.Specs </span><span class="cov8" title="1">{
                                ts, ok := spec.(*ast.TypeSpec)
                                if !ok </span><span class="cov0" title="0">{
                                        continue</span>
                                }
                                <span class="cov8" title="1">it, ok := ts.Type.(*ast.InterfaceType)
                                if !ok </span><span class="cov8" title="1">{
                                        continue</span>
                                }

                                <span class="cov8" title="1">ch &lt;- &amp;namedInterface{ts.Name, it, getTypeSpecTypeParams(ts)}</span>
                        }
                }
                <span class="cov8" title="1">close(ch)</span>
        }()
        <span class="cov8" title="1">return ch</span>
}

// isVariadic returns whether the function is variadic.
func isVariadic(f *ast.FuncType) bool <span class="cov8" title="1">{
        nargs := len(f.Params.List)
        if nargs == 0 </span><span class="cov8" title="1">{
                return false
        }</span>
        <span class="cov0" title="0">_, ok := f.Params.List[nargs-1].Type.(*ast.Ellipsis)
        return ok</span>
}

// packageNameOfDir get package import path via dir
func packageNameOfDir(srcDir string) (string, error) <span class="cov0" title="0">{
        files, err := ioutil.ReadDir(srcDir)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatal(err)
        }</span>

        <span class="cov0" title="0">var goFilePath string
        for _, file := range files </span><span class="cov0" title="0">{
                if !file.IsDir() &amp;&amp; strings.HasSuffix(file.Name(), ".go") </span><span class="cov0" title="0">{
                        goFilePath = file.Name()
                        break</span>
                }
        }
        <span class="cov0" title="0">if goFilePath == "" </span><span class="cov0" title="0">{
                return "", fmt.Errorf("go source file not found %s", srcDir)
        }</span>

        <span class="cov0" title="0">packageImport, err := parsePackageImport(srcDir)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov0" title="0">return packageImport, nil</span>
}

var errOutsideGoPath = errors.New("source directory is outside GOPATH")
</pre>
		
		<pre class="file" id="file41" style="display: none">// Copyright 2012 Google Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package main

// This file contains the model construction by reflection.

import (
        "bytes"
        "encoding/gob"
        "flag"
        "fmt"
        "go/build"
        "io"
        "io/ioutil"
        "log"
        "os"
        "os/exec"
        "path/filepath"
        "runtime"
        "strings"
        "text/template"

        "github.com/golang/mock/mockgen/model"
)

var (
        progOnly   = flag.Bool("prog_only", false, "(reflect mode) Only generate the reflection program; write it to stdout and exit.")
        execOnly   = flag.String("exec_only", "", "(reflect mode) If set, execute this reflection program.")
        buildFlags = flag.String("build_flags", "", "(reflect mode) Additional flags for go build.")
)

// reflectMode generates mocks via reflection on an interface.
func reflectMode(importPath string, symbols []string) (*model.Package, error) <span class="cov0" title="0">{
        if *execOnly != "" </span><span class="cov0" title="0">{
                return run(*execOnly)
        }</span>

        <span class="cov0" title="0">program, err := writeProgram(importPath, symbols)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if *progOnly </span><span class="cov0" title="0">{
                if _, err := os.Stdout.Write(program); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">os.Exit(0)</span>
        }

        <span class="cov0" title="0">wd, _ := os.Getwd()

        // Try to run the reflection program  in the current working directory.
        if p, err := runInDir(program, wd); err == nil </span><span class="cov0" title="0">{
                return p, nil
        }</span>

        // Try to run the program in the same directory as the input package.
        <span class="cov0" title="0">if p, err := build.Import(importPath, wd, build.FindOnly); err == nil </span><span class="cov0" title="0">{
                dir := p.Dir
                if p, err := runInDir(program, dir); err == nil </span><span class="cov0" title="0">{
                        return p, nil
                }</span>
        }

        // Try to run it in a standard temp directory.
        <span class="cov0" title="0">return runInDir(program, "")</span>
}

func writeProgram(importPath string, symbols []string) ([]byte, error) <span class="cov0" title="0">{
        var program bytes.Buffer
        data := reflectData{
                ImportPath: importPath,
                Symbols:    symbols,
        }
        if err := reflectProgram.Execute(&amp;program, &amp;data); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return program.Bytes(), nil</span>
}

// run the given program and parse the output as a model.Package.
func run(program string) (*model.Package, error) <span class="cov0" title="0">{
        f, err := ioutil.TempFile("", "")
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">filename := f.Name()
        defer os.Remove(filename)
        if err := f.Close(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Run the program.
        <span class="cov0" title="0">cmd := exec.Command(program, "-output", filename)
        cmd.Stdout = os.Stdout
        cmd.Stderr = os.Stderr
        if err := cmd.Run(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">f, err = os.Open(filename)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Process output.
        <span class="cov0" title="0">var pkg model.Package
        if err := gob.NewDecoder(f).Decode(&amp;pkg); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if err := f.Close(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return &amp;pkg, nil</span>
}

// runInDir writes the given program into the given dir, runs it there, and
// parses the output as a model.Package.
func runInDir(program []byte, dir string) (*model.Package, error) <span class="cov0" title="0">{
        // We use TempDir instead of TempFile so we can control the filename.
        tmpDir, err := ioutil.TempDir(dir, "gomock_reflect_")
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{
                if err := os.RemoveAll(tmpDir); err != nil </span><span class="cov0" title="0">{
                        log.Printf("failed to remove temp directory: %s", err)
                }</span>
        }()
        <span class="cov0" title="0">const progSource = "prog.go"
        var progBinary = "prog.bin"
        if runtime.GOOS == "windows" </span><span class="cov0" title="0">{
                // Windows won't execute a program unless it has a ".exe" suffix.
                progBinary += ".exe"
        }</span>

        <span class="cov0" title="0">if err := ioutil.WriteFile(filepath.Join(tmpDir, progSource), program, 0600); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">cmdArgs := []string{}
        cmdArgs = append(cmdArgs, "build")
        if *buildFlags != "" </span><span class="cov0" title="0">{
                cmdArgs = append(cmdArgs, strings.Split(*buildFlags, " ")...)
        }</span>
        <span class="cov0" title="0">cmdArgs = append(cmdArgs, "-o", progBinary, progSource)

        // Build the program.
        buf := bytes.NewBuffer(nil)
        cmd := exec.Command("go", cmdArgs...)
        cmd.Dir = tmpDir
        cmd.Stdout = os.Stdout
        cmd.Stderr = io.MultiWriter(os.Stderr, buf)
        if err := cmd.Run(); err != nil </span><span class="cov0" title="0">{
                sErr := buf.String()
                if strings.Contains(sErr, `cannot find package "."`) &amp;&amp;
                        strings.Contains(sErr, "github.com/golang/mock/mockgen/model") </span><span class="cov0" title="0">{
                        fmt.Fprint(os.Stderr, "Please reference the steps in the README to fix this error:\n\thttps://github.com/golang/mock#reflect-vendoring-error.\n")
                        return nil, err
                }</span>
                <span class="cov0" title="0">return nil, err</span>
        }

        <span class="cov0" title="0">return run(filepath.Join(tmpDir, progBinary))</span>
}

type reflectData struct {
        ImportPath string
        Symbols    []string
}

// This program reflects on an interface value, and prints the
// gob encoding of a model.Package to standard output.
// JSON doesn't work because of the model.Type interface.
var reflectProgram = template.Must(template.New("program").Parse(`
package main

import (
        "encoding/gob"
        "flag"
        "fmt"
        "os"
        "path"
        "reflect"

        "github.com/golang/mock/mockgen/model"

        pkg_ {{printf "%q" .ImportPath}}
)

var output = flag.String("output", "", "The output file name, or empty to use stdout.")

func main() {
        flag.Parse()

        its := []struct{
                sym string
                typ reflect.Type
        }{
                {{range .Symbols}}
                { {{printf "%q" .}}, reflect.TypeOf((*pkg_.{{.}})(nil)).Elem()},
                {{end}}
        }
        pkg := &amp;model.Package{
                // NOTE: This behaves contrary to documented behaviour if the
                // package name is not the final component of the import path.
                // The reflect package doesn't expose the package name, though.
                Name: path.Base({{printf "%q" .ImportPath}}),
        }

        for _, it := range its {
                intf, err := model.InterfaceFromInterfaceType(it.typ)
                if err != nil {
                        fmt.Fprintf(os.Stderr, "Reflection: %v\n", err)
                        os.Exit(1)
                }
                intf.Name = it.sym
                pkg.Interfaces = append(pkg.Interfaces, intf)
        }

        outfile := os.Stdout
        if len(*output) != 0 {
                var err error
                outfile, err = os.Create(*output)
                if err != nil {
                        fmt.Fprintf(os.Stderr, "failed to open output file %q", *output)
                }
                defer func() {
                        if err := outfile.Close(); err != nil {
                                fmt.Fprintf(os.Stderr, "failed to close output file %q", *output)
                                os.Exit(1)
                        }
                }()
        }

        if err := gob.NewEncoder(outfile).Encode(pkg); err != nil {
                fmt.Fprintf(os.Stderr, "gob encode: %v\n", err)
                os.Exit(1)
        }
}
`))
</pre>
		
		<pre class="file" id="file42" style="display: none">// Copyright 2022 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package main

import (
        "fmt"
        "log"
        "runtime/debug"
)

func printModuleVersion() <span class="cov0" title="0">{
        if bi, exists := debug.ReadBuildInfo(); exists </span><span class="cov0" title="0">{
                fmt.Println(bi.Main.Version)
        }</span> else<span class="cov0" title="0"> {
                log.Printf("No version information found. Make sure to use " +
                        "GO111MODULE=on when running 'go get' in order to use specific " +
                        "version of the binary.")
        }</span>
}
</pre>
		
		<pre class="file" id="file43" style="display: none">// Code generated by MockGen. DO NOT EDIT.
// Source: github.com/golang/mock/sample/concurrent (interfaces: Math)

// Package mock_concurrent is a generated GoMock package.
package mock_concurrent

import (
        reflect "reflect"

        gomock "github.com/golang/mock/gomock"
)

// MockMath is a mock of Math interface.
type MockMath struct {
        ctrl     *gomock.Controller
        recorder *MockMathMockRecorder
}

// MockMathMockRecorder is the mock recorder for MockMath.
type MockMathMockRecorder struct {
        mock *MockMath
}

// NewMockMath creates a new mock instance.
func NewMockMath(ctrl *gomock.Controller) *MockMath <span class="cov8" title="1">{
        mock := &amp;MockMath{ctrl: ctrl}
        mock.recorder = &amp;MockMathMockRecorder{mock}
        return mock
}</span>

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockMath) EXPECT() *MockMathMockRecorder <span class="cov8" title="1">{
        return m.recorder
}</span>

// Sum mocks base method.
func (m *MockMath) Sum(arg0, arg1 int) int <span class="cov8" title="1">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Sum", arg0, arg1)
        ret0, _ := ret[0].(int)
        return ret0
}</span>

// Sum indicates an expected call of Sum.
func (mr *MockMathMockRecorder) Sum(arg0, arg1 interface{}) *gomock.Call <span class="cov8" title="1">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Sum", reflect.TypeOf((*MockMath)(nil).Sum), arg0, arg1)
}</span>
</pre>
		
		<pre class="file" id="file44" style="display: none">// Package user is an example package with an interface.
package user

//go:generate mockgen -destination mock_user_test.go -package user_test github.com/golang/mock/sample Index,Embed,Embedded

// Random bunch of imports to test mockgen.
import (
        "io"

        btz "bytes"
        "hash"
        "log"
        "net"
        "net/http"

        // Two imports with the same base name.
        t1 "html/template"

        t2 "text/template"

        "github.com/golang/mock/sample/imp1"

        // Dependencies outside the standard library.

        renamed2 "github.com/golang/mock/sample/imp2"

        . "github.com/golang/mock/sample/imp3"

        imp_four "github.com/golang/mock/sample/imp4"
)

// calls itself "imp_four"

// A bizarre interface to test corner cases in mockgen.
// This would normally be in its own file or package,
// separate from the user of it (e.g. io.Reader).
type Index interface {
        Get(key string) interface{}
        GetTwo(key1, key2 string) (v1, v2 interface{})
        Put(key string, value interface{})

        // Check that imports are handled correctly.
        Summary(buf *btz.Buffer, w io.Writer)
        Other() hash.Hash
        Templates(a t1.CSS, b t2.FuncMap)

        // A method with an anonymous argument.
        Anon(string)

        // Methods using foreign types outside the standard library.
        ForeignOne(imp1.Imp1)
        ForeignTwo(renamed2.Imp2)
        ForeignThree(Imp3)
        ForeignFour(imp_four.Imp4)

        // A method that returns a nillable type.
        NillableRet() error
        // A method that returns a non-interface type.
        ConcreteRet() chan&lt;- bool

        // Methods with an ellipsis argument.
        Ellip(fmt string, args ...interface{})
        EllipOnly(...string)

        // A method with a pointer argument that we will set.
        Ptr(arg *int)

        // A method with a slice argument and an array return.
        Slice(a []int, b []byte) [3]int

        // A method with channel arguments.
        Chan(a chan int, b chan&lt;- hash.Hash)

        // A method with a function argument.
        Func(f func(http.Request) (int, bool))

        // A method with a map argument.
        Map(a map[int]hash.Hash)

        // Methods with an unnamed empty struct argument.
        Struct(a struct{})          // not so likely
        StructChan(a chan struct{}) // a bit more common
}

// An interface with an embedded interface.
type Embed interface {
        RegularMethod()
        Embedded
        imp1.ForeignEmbedded
}

type Embedded interface {
        EmbeddedMethod()
}

// some random use of another package that isn't needed by the interface.
var _ net.Addr

// A function that we will test that uses the above interface.
// It takes a list of keys and values, and puts them in the index.
func Remember(index Index, keys []string, values []interface{}) <span class="cov8" title="1">{
        for i, k := range keys </span><span class="cov8" title="1">{
                index.Put(k, values[i])
        }</span>
        <span class="cov8" title="1">err := index.NillableRet()
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Woah! %v", err)
        }</span>
        <span class="cov8" title="1">if len(keys) &gt; 0 &amp;&amp; keys[0] == "a" </span><span class="cov8" title="1">{
                index.Ellip("%d", 0, 1, 1, 2, 3)
                index.Ellip("%d", 1, 3, 6, 10, 15)
                index.EllipOnly("arg")
        }</span>
}

func GrabPointer(index Index) int <span class="cov8" title="1">{
        var a int
        index.Ptr(&amp;a)
        return a
}</span>
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
